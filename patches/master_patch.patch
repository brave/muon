diff --git a/base/threading/thread_restrictions.h b/base/threading/thread_restrictions.h
index 705ba4ddee22fd81d7fbed51f4c10a574a123284..3dee5251aa0538e8dfd524605f1a091fc4006e85 100644
--- a/base/threading/thread_restrictions.h
+++ b/base/threading/thread_restrictions.h
@@ -34,6 +34,13 @@ class StatisticsProviderImpl;
 namespace chrome_browser_net {
 class Predictor;
 }
+
+namespace atom {
+namespace api {
+  class Session;
+}
+}
+
 namespace content {
 class BrowserGpuChannelHostFactory;
 class BrowserGpuMemoryBufferManager;
@@ -479,6 +486,9 @@ class BASE_EXPORT ThreadRestrictions {
   friend class ui::CommandBufferLocal;
   friend class ui::GpuState;
 
+  // BB: MUON ones that maybe need to be fixed???
+  friend class atom::api::Session;
+
   // END ALLOWED USAGE.
   // BEGIN USAGE THAT NEEDS TO BE FIXED.
   friend class ::chromeos::BlockingMethodCaller;  // http://crbug.com/125360
diff --git a/build/config/BUILDCONFIG.gn b/build/config/BUILDCONFIG.gn
index fcc00ee0e49f101cb1b10629747c4c4fa521776d..9ae55ab55731726f08f356760e2f78cd24f7bef7 100644
--- a/build/config/BUILDCONFIG.gn
+++ b/build/config/BUILDCONFIG.gn
@@ -148,6 +148,8 @@ declare_args() {
   host_toolchain = ""
 
   # DON'T ADD MORE FLAGS HERE. Read the comment above.
+  # Build chromium without muon flags
+  muon_chromium_build = false
 }
 
 declare_args() {
@@ -538,6 +540,14 @@ default_compiler_configs = [
   "//build/config/sanitizers:default_sanitizer_flags",
 ]
 
+if (!muon_chromium_build) {
+  default_compiler_configs -= [ "//build/config/compiler:default_include_dirs" ]
+  default_compiler_configs += [
+    "//electron/build:muon_include_dirs",
+    "//build/config/compiler:default_include_dirs"
+  ]
+}
+
 if (is_win) {
   default_compiler_configs += [
     "//build/config/win:default_crt",
diff --git a/build/config/chrome_build.gni b/build/config/chrome_build.gni
index 4bb4a043cbbcb562aed8926867660547cd7f018c..769bc73607b600d549b6185a37d6b0cc35ded9f6 100644
--- a/build/config/chrome_build.gni
+++ b/build/config/chrome_build.gni
@@ -11,6 +11,7 @@ declare_args() {
   # Break chrome.dll into multple pieces based on process type. Only available
   # on Windows.
   is_multi_dll_chrome = is_win && !is_component_build
+  branding_path_component = ""
 
   # Turn this on to generate order files. See
   # https://chromium.googlesource.com/chromium/src/+/master/docs/win_order_files.md
@@ -19,8 +20,10 @@ declare_args() {
 
 # Refers to the subdirectory for branding in various places including
 # chrome/app/theme.
+if (branding_path_component == "") {
 if (is_chrome_branded) {
   branding_path_component = "google_chrome"
 } else {
   branding_path_component = "chromium"
 }
+}
diff --git a/build/toolchain/win/BUILD.gn b/build/toolchain/win/BUILD.gn
index eb3e2b2b377dde31e062be46837bf509ecab0325..a4bee6058da2366f8b5358072a845828bd080b97 100644
--- a/build/toolchain/win/BUILD.gn
+++ b/build/toolchain/win/BUILD.gn
@@ -6,6 +6,7 @@ import("//build/config/clang/clang.gni")
 import("//build/config/compiler/compiler.gni")
 import("//build/config/sanitizers/sanitizers.gni")
 import("//build/config/win/visual_studio_version.gni")
+import("//build/toolchain/cc_wrapper.gni")
 import("//build/toolchain/clang_static_analyzer.gni")
 import("//build/toolchain/goma.gni")
 import("//build/toolchain/toolchain.gni")
@@ -28,6 +29,8 @@ if (use_goma) {
   } else {
     goma_prefix = "$goma_dir/gomacc "
   }
+} else if (cc_wrapper != "") {
+  goma_prefix = "$cc_wrapper "
 } else {
   goma_prefix = ""
 }
diff --git a/chrome/BUILD.gn b/chrome/BUILD.gn
index a47af42a5a5afc1560f11ee0ccfa5fc177745caa..a35097ec298e2937b06584d3fabf48b7255eae3f 100644
--- a/chrome/BUILD.gn
+++ b/chrome/BUILD.gn
@@ -41,6 +41,11 @@ if (is_android) {
   import("//build/util/version.gni")
   import("//media/cdm/library_cdm/cdm_paths.gni")
   import("//third_party/icu/config.gni")
+  if (!muon_chromium_build) {
+    # Avoid mac app/framework naming conflicts
+    chrome_product_full_name = "Google Chrome"
+    chrome_product_short_name = "Google Chrome"
+  }
 }
 
 assert(!is_ios, "Chromium/iOS shouldn't use anything in //chrome")
diff --git a/chrome/app/BUILD.gn b/chrome/app/BUILD.gn
index dc22933980e63004cfbc2378e92d5c450663179b..8adef35ebaf861c4e52424ddddfad3c33a3508e9 100644
--- a/chrome/app/BUILD.gn
+++ b/chrome/app/BUILD.gn
@@ -454,6 +454,8 @@ service_manifest("chrome_content_packaged_services_manifest_overlay") {
       "//ui/accessibility:manifest",
     ]
   }
+
+  packaged_services += [ "//electron/app:tor_launcher_manifest" ]
 }
 
 # Per-profile services.
diff --git a/chrome/browser/chrome_content_browser_manifest_overlay.json b/chrome/browser/chrome_content_browser_manifest_overlay.json
index 3608badd382ec076de290fc0ff065cd88043cd75..052e7b400b5e19ac3e5ec47368e56be868462f48 100644
--- a/chrome/browser/chrome_content_browser_manifest_overlay.json
+++ b/chrome/browser/chrome_content_browser_manifest_overlay.json
@@ -15,7 +15,7 @@
           "extensions.StashService",
           "metrics.mojom.CallStackProfileCollector",
           "mojom.ModuleEventSink",
-          "rappor.mojom.RapporRecorder",
+//          "rappor.mojom.RapporRecorder",
           "safe_browsing.mojom.SafeBrowsing",
           "translate.mojom.ContentTranslateDriver"
         ],
@@ -63,6 +63,7 @@
         "removable_storage_writer": [ "removable_storage_writer" ],
         "secure_channel": [ "secure_channel" ],
         "shortcut_viewer_app": [ "shortcut_viewer" ],
+        "tor_launcher": [ "tor_launcher" ],
         "ui": [
           "display_dev",
           "ime_registrar",
diff --git a/chrome/browser/chrome_content_utility_manifest_overlay.json b/chrome/browser/chrome_content_utility_manifest_overlay.json
index 03d7cd6b486001765096df3bfe95624fd2700c42..a5dbd36e97f36417b861c41a2bfb201a8640aba2 100644
--- a/chrome/browser/chrome_content_utility_manifest_overlay.json
+++ b/chrome/browser/chrome_content_utility_manifest_overlay.json
@@ -10,6 +10,7 @@
           "payments.mojom.PaymentManifestParser",
           "heap_profiling.mojom.ProfilingClient",
           "proxy_resolver.mojom.ProxyResolverFactory",
+          "tor.mojom.TorLauncher",
           "safe_json.mojom.SafeJsonParser"
         ]
       }
diff --git a/chrome/browser/chrome_service.cc b/chrome/browser/chrome_service.cc
index 7673d9f881f37abda70bfcf835402b727dd6288d..aa1a4bf8d0cd57e3bbfd5822c54304f5b8c6c46f 100644
--- a/chrome/browser/chrome_service.cc
+++ b/chrome/browser/chrome_service.cc
@@ -47,8 +47,10 @@ class ChromeService::IOThreadContext : public service_manager::Service {
                                                base::Unretained(&launchable_)),
                            ui_task_runner);
 #endif
+#if defined(MUON_CHROMIUM_BUILD)
     registry_.AddInterface(base::BindRepeating(
         &startup_metric_utils::StartupMetricHostImpl::Create));
+#endif
 #if BUILDFLAG(ENABLE_SPELLCHECK)
     registry_with_source_info_.AddInterface(
         base::BindRepeating(&SpellCheckHostChromeImpl::Create), ui_task_runner);
diff --git a/chrome/browser/importer/external_process_importer_client.h b/chrome/browser/importer/external_process_importer_client.h
index 864a6951115dda5ed74963f18b35692960397d50..3e1a2b719521ac2c60bae05f94e409bc4c7da022 100644
--- a/chrome/browser/importer/external_process_importer_client.h
+++ b/chrome/browser/importer/external_process_importer_client.h
@@ -88,6 +88,8 @@ class ExternalProcessImporterClient
   void OnAutofillFormDataImportGroup(
       const std::vector<ImporterAutofillFormDataEntry>&
           autofill_form_data_entry_group) override;
+  void OnCookiesImportStart(uint32_t total_cookies_count) override {};
+  void OnCookiesImportGroup(const std::vector<ImportedCookieEntry>& cookies_group) override {};
   void OnIE7PasswordReceived(
       const importer::ImporterIE7PasswordInfo& importer_password_info) override;
 
diff --git a/chrome/browser/importer/external_process_importer_host.h b/chrome/browser/importer/external_process_importer_host.h
index 08c6f28746cc5f345114a942834db18f5c7a1d41..3a43ae76f054ba449e3b892ea752c62fdad2e5a3 100644
--- a/chrome/browser/importer/external_process_importer_host.h
+++ b/chrome/browser/importer/external_process_importer_host.h
@@ -74,7 +74,10 @@ class ExternalProcessImporterHost
 
  private:
   // ExternalProcessImporterHost deletes itself in OnImportEnded().
+ protected:
   ~ExternalProcessImporterHost() override;
+ private:
+  friend class BraveExternalProcessImporterHost;
 
   // Launches the utility process that starts the import task, unless bookmark
   // or template model are not yet loaded. If load is not detected, this method
diff --git a/chrome/browser/importer/importer_uma.cc b/chrome/browser/importer/importer_uma.cc
index da87e84ffe7c2193ea16d24f1ee1174c51c9503f..b297c97bfde88f7610ec19b007eaa231b64cf1c2 100644
--- a/chrome/browser/importer/importer_uma.cc
+++ b/chrome/browser/importer/importer_uma.cc
@@ -59,6 +59,9 @@ void LogImporterUseToMetrics(const std::string& metric_postfix,
     case TYPE_BOOKMARKS_FILE:
       metrics_type = IMPORTER_METRICS_BOOKMARKS_FILE;
       break;
+    case TYPE_CHROME:
+      NOTREACHED();
+      break;
   }
 
   // Note: This leaks memory, which is the expected behavior as the factory
diff --git a/chrome/browser/importer/in_process_importer_bridge.cc b/chrome/browser/importer/in_process_importer_bridge.cc
index 5832fa66c715fe82a3e865c7bde490ef6f6b14b6..2ff87fd3fd81f803c327aba2160f2d6851f612e5 100644
--- a/chrome/browser/importer/in_process_importer_bridge.cc
+++ b/chrome/browser/importer/in_process_importer_bridge.cc
@@ -59,6 +59,8 @@ history::VisitSource ConvertImporterVisitSourceToHistoryVisitSource(
       return history::SOURCE_IE_IMPORTED;
     case importer::VISIT_SOURCE_SAFARI_IMPORTED:
       return history::SOURCE_SAFARI_IMPORTED;
+    case importer::VISIT_SOURCE_CHROME_IMPORTED:
+      break;
   }
   NOTREACHED();
   return history::SOURCE_SYNCED;
diff --git a/chrome/browser/importer/in_process_importer_bridge.h b/chrome/browser/importer/in_process_importer_bridge.h
index 247d24220beb7d176b890d7c2d45bdd2dfd8db99..c270bba0fabb557e8d3d1df8ac166bbb00ed6e8b 100644
--- a/chrome/browser/importer/in_process_importer_bridge.h
+++ b/chrome/browser/importer/in_process_importer_bridge.h
@@ -68,7 +68,9 @@ class InProcessImporterBridge : public ImporterBridge {
   // End ImporterBridge implementation.
 
  private:
+ protected:
   ~InProcessImporterBridge() override;
+ private:
 
   ProfileWriter* const writer_;  // weak
   const base::WeakPtr<ExternalProcessImporterHost> host_;
diff --git a/chrome/browser/metrics/metrics_reporting_state.cc b/chrome/browser/metrics/metrics_reporting_state.cc
index 2592dea8c30aa5e7b9daf614a63fe964471bab7a..5fede5d8ee00b4b06d437b4272ec19a0146c7fdb 100644
--- a/chrome/browser/metrics/metrics_reporting_state.cc
+++ b/chrome/browser/metrics/metrics_reporting_state.cc
@@ -60,6 +60,7 @@ void SetMetricsReporting(bool to_update_pref,
   g_browser_process->local_state()->SetBoolean(
       metrics::prefs::kMetricsReportingEnabled, updated_pref);
 
+#if defined(MUON_CHROMIUM_BUILD)
   UpdateMetricsPrefsOnPermissionChange(updated_pref);
 
   // Uses the current state of whether reporting is enabled to enable services.
@@ -71,6 +72,7 @@ void SetMetricsReporting(bool to_update_pref,
   } else {
     RecordMetricsReportingHistogramValue(METRICS_REPORTING_ERROR);
   }
+#endif
   if (!callback_fn.is_null())
     callback_fn.Run(updated_pref);
 }
diff --git a/chrome/browser/password_manager/password_store_factory.cc b/chrome/browser/password_manager/password_store_factory.cc
index a234d584154069f036c245823307466df4c7a671..96e21b99d5ac4cc2614aa0f5160820e831608846 100644
--- a/chrome/browser/password_manager/password_store_factory.cc
+++ b/chrome/browser/password_manager/password_store_factory.cc
@@ -125,8 +125,10 @@ PasswordStoreFactory::PasswordStoreFactory()
 #if defined(SYNC_PASSWORD_REUSE_DETECTION_ENABLED)
   // TODO(crbug.com/715987). Remove when PasswordReuseDetector is decoupled
   // from PasswordStore.
+#if defined(MUON_CHROMIUM_BUILD)
   DependsOn(SigninManagerFactory::GetInstance());
 #endif
+#endif
 }
 
 PasswordStoreFactory::~PasswordStoreFactory() {}
@@ -283,12 +285,14 @@ PasswordStoreFactory::BuildServiceInstanceFor(
   password_manager_util::CleanUserDataInBlacklistedCredentials(
       ps.get(), profile->GetPrefs(), 60);
 
+#if defined(MUON_CHROMIUM_BUILD)
 #if defined(OS_WIN) || defined(OS_MACOSX) || \
     (defined(OS_LINUX) && !defined(OS_CHROMEOS))
   std::unique_ptr<password_manager::PasswordStoreSigninNotifier> notifier =
       std::make_unique<password_manager::PasswordStoreSigninNotifierImpl>(
           profile);
   ps->SetPasswordStoreSigninNotifier(std::move(notifier));
+#endif
 #endif
 
   return ps;
diff --git a/chrome/browser/printing/print_view_manager_base.cc b/chrome/browser/printing/print_view_manager_base.cc
index 9b0c15b3c5016707788476295d53ab9d8a80e338..7dd660e280f28cf73019f45a111d4b86704aaf07 100644
--- a/chrome/browser/printing/print_view_manager_base.cc
+++ b/chrome/browser/printing/print_view_manager_base.cc
@@ -68,13 +68,13 @@ using PrintSettingsCallback =
 
 void ShowWarningMessageBox(const base::string16& message) {
   // Runs always on the UI thread.
-  static bool is_dialog_shown = false;
-  if (is_dialog_shown)
-    return;
+  // static bool is_dialog_shown = false;
+  // if (is_dialog_shown)
+  //   return;
   // Block opening dialog from nested task.
-  base::AutoReset<bool> auto_reset(&is_dialog_shown, true);
+  // base::AutoReset<bool> auto_reset(&is_dialog_shown, true);
 
-  chrome::ShowWarningMessageBox(nullptr, base::string16(), message);
+  // chrome::ShowWarningMessageBox(nullptr, base::string16(), message);
 }
 
 #if BUILDFLAG(ENABLE_PRINT_PREVIEW)
diff --git a/chrome/browser/renderer_host/chrome_extension_message_filter.cc b/chrome/browser/renderer_host/chrome_extension_message_filter.cc
index 30897fe6780343110f48a05b56827bd8476342b6..aef7d7b993743037776eccc62df09c92342a622b 100644
--- a/chrome/browser/renderer_host/chrome_extension_message_filter.cc
+++ b/chrome/browser/renderer_host/chrome_extension_message_filter.cc
@@ -16,16 +16,19 @@
 #include "base/task_scheduler/post_task.h"
 #include "chrome/browser/browser_process.h"
 #include "chrome/browser/chrome_notification_types.h"
+#if 0
 #include "chrome/browser/extensions/activity_log/activity_action_constants.h"
 #include "chrome/browser/extensions/activity_log/activity_actions.h"
 #include "chrome/browser/extensions/activity_log/activity_log.h"
 #include "chrome/browser/extensions/api/activity_log_private/activity_log_private_api.h"
+#endif  // 0
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/browser/profiles/profile_manager.h"
 #include "chrome/common/extensions/chrome_extension_messages.h"
 #include "content/public/browser/notification_service.h"
 #include "content/public/browser/render_process_host.h"
 #include "extensions/browser/extension_system.h"
+#include "extensions/browser/info_map.h"
 #include "extensions/common/extension_messages.h"
 #include "extensions/common/extension_set.h"
 #include "extensions/common/file_util.h"
@@ -41,6 +44,7 @@ const uint32_t kExtensionFilteredMessageClasses[] = {
     ChromeExtensionMsgStart, ExtensionMsgStart,
 };
 
+#if 0
 // Logs an action to the extension activity log for the specified profile.
 void AddActionToExtensionActivityLog(Profile* profile,
                                      extensions::ActivityLog* activity_log,
@@ -53,6 +57,7 @@ void AddActionToExtensionActivityLog(Profile* profile,
     action->set_page_incognito(profile->IsOffTheRecord());
   activity_log->LogAction(action);
 }
+#endif  // 0
 
 }  // namespace
 
@@ -63,7 +68,7 @@ ChromeExtensionMessageFilter::ChromeExtensionMessageFilter(
                            arraysize(kExtensionFilteredMessageClasses)),
       render_process_id_(render_process_id),
       profile_(profile),
-      activity_log_(extensions::ActivityLog::GetInstance(profile)),
+      // activity_log_(extensions::ActivityLog::GetInstance(profile)),
       extension_info_map_(
           extensions::ExtensionSystem::Get(profile)->info_map()) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
@@ -82,12 +87,14 @@ bool ChromeExtensionMessageFilter::OnMessageReceived(
   IPC_BEGIN_MESSAGE_MAP(ChromeExtensionMessageFilter, message)
     IPC_MESSAGE_HANDLER_DELAY_REPLY(ExtensionHostMsg_GetMessageBundle,
                                     OnGetExtMessageBundle)
+#if 0
     IPC_MESSAGE_HANDLER(ExtensionHostMsg_AddAPIActionToActivityLog,
                         OnAddAPIActionToExtensionActivityLog);
     IPC_MESSAGE_HANDLER(ExtensionHostMsg_AddDOMActionToActivityLog,
                         OnAddDOMActionToExtensionActivityLog);
     IPC_MESSAGE_HANDLER(ExtensionHostMsg_AddEventToActivityLog,
                         OnAddEventToExtensionActivityLog);
+#endif  // 0
     IPC_MESSAGE_UNHANDLED(handled = false)
   IPC_END_MESSAGE_MAP()
 
@@ -97,9 +104,11 @@ bool ChromeExtensionMessageFilter::OnMessageReceived(
 void ChromeExtensionMessageFilter::OverrideThreadForMessage(
     const IPC::Message& message, BrowserThread::ID* thread) {
   switch (message.type()) {
+#if 0
     case ExtensionHostMsg_AddAPIActionToActivityLog::ID:
     case ExtensionHostMsg_AddDOMActionToActivityLog::ID:
     case ExtensionHostMsg_AddEventToActivityLog::ID:
+#endif  // 0
       *thread = BrowserThread::UI;
       break;
     default:
@@ -181,6 +190,7 @@ void ChromeExtensionMessageFilter::OnGetExtMessageBundleAsync(
   Send(reply_msg);
 }
 
+#if 0
 void ChromeExtensionMessageFilter::OnAddAPIActionToExtensionActivityLog(
     const std::string& extension_id,
     const ExtensionHostMsg_APIActionOrEvent_Params& params) {
@@ -231,6 +241,7 @@ void ChromeExtensionMessageFilter::OnAddEventToExtensionActivityLog(
   }
   AddActionToExtensionActivityLog(profile_, activity_log_, action);
 }
+#endif  // 0
 
 void ChromeExtensionMessageFilter::Observe(
     int type,
@@ -238,7 +249,7 @@ void ChromeExtensionMessageFilter::Observe(
     const content::NotificationDetails& details) {
   DCHECK_EQ(chrome::NOTIFICATION_PROFILE_DESTROYED, type);
   profile_ = NULL;
-  activity_log_ = nullptr;
+  // activity_log_ = nullptr;
 }
 
 bool ChromeExtensionMessageFilter::ShouldLogExtensionAction(
@@ -247,7 +258,8 @@ bool ChromeExtensionMessageFilter::ShouldLogExtensionAction(
   // conditions (e.g. logging gets disabled but the renderer sends the message
   // before it gets updated), we still need this check here.
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  return profile_ &&
-         g_browser_process->profile_manager()->IsValidProfile(profile_) &&
-         activity_log_ && activity_log_->ShouldLog(extension_id);
+  // return profile_ &&
+  //        g_browser_process->profile_manager()->IsValidProfile(profile_) &&
+  //        activity_log_ && activity_log_->ShouldLog(extension_id);
+  return false;
 }
diff --git a/chrome/browser/renderer_host/chrome_extension_message_filter.h b/chrome/browser/renderer_host/chrome_extension_message_filter.h
index 9f0003bc2d80d7c76ab9dd17393d0188fe1ac6fd..88d75d4091fb3dc282998a5d44e63cbfc2f29d2f 100644
--- a/chrome/browser/renderer_host/chrome_extension_message_filter.h
+++ b/chrome/browser/renderer_host/chrome_extension_message_filter.h
@@ -55,6 +55,7 @@ class ChromeExtensionMessageFilter : public content::BrowserMessageFilter,
       const std::string& main_extension_id,
       const std::string& default_locale,
       IPC::Message* reply_msg);
+#if 0
   void OnAddAPIActionToExtensionActivityLog(
       const std::string& extension_id,
       const ExtensionHostMsg_APIActionOrEvent_Params& params);
@@ -67,6 +68,7 @@ class ChromeExtensionMessageFilter : public content::BrowserMessageFilter,
   void OnAddEventToExtensionActivityLog(
       const std::string& extension_id,
       const ExtensionHostMsg_APIActionOrEvent_Params& params);
+#endif  // 0
 
   // content::NotificationObserver implementation.
   void Observe(int type,
diff --git a/chrome/browser/resource_coordinator/tab_lifecycle_unit.cc b/chrome/browser/resource_coordinator/tab_lifecycle_unit.cc
index d36e89e2ba3b5b7fa7f7f05b6ab583c8bd859db9..68dc47f1da5df0e5db5be244567291ce89a420a0 100644
--- a/chrome/browser/resource_coordinator/tab_lifecycle_unit.cc
+++ b/chrome/browser/resource_coordinator/tab_lifecycle_unit.cc
@@ -12,6 +12,7 @@
 #include "base/metrics/histogram_macros.h"
 #include "base/optional.h"
 #include "base/process/process_metrics.h"
+#include "chrome/browser/browser_process.h"
 #include "chrome/browser/devtools/devtools_window.h"
 #include "chrome/browser/media/webrtc/media_capture_devices_dispatcher.h"
 #include "chrome/browser/media/webrtc/media_stream_capture_indicator.h"
@@ -24,6 +25,7 @@
 #include "chrome/browser/resource_coordinator/tab_lifecycle_observer.h"
 #include "chrome/browser/resource_coordinator/tab_lifecycle_unit_source.h"
 #include "chrome/browser/resource_coordinator/tab_load_tracker.h"
+#include "chrome/browser/resource_coordinator/tab_manager.h"
 #include "chrome/browser/resource_coordinator/tab_manager_features.h"
 #include "chrome/browser/resource_coordinator/time.h"
 #include "chrome/browser/resource_coordinator/utils.h"
@@ -699,7 +701,7 @@ void TabLifecycleUnitSource::TabLifecycleUnit::FinishDiscard(
       content::WebContents::CreateParams::kNoRendererProcess;
   create_params.last_active_time = old_contents->GetLastActiveTime();
   std::unique_ptr<content::WebContents> null_contents =
-      content::WebContents::Create(create_params);
+      g_browser_process->GetTabManager()->CreateNullContents(create_params, old_contents);
   content::WebContents* raw_null_contents = null_contents.get();
 
   // Attach the ResourceCoordinatorTabHelper. In production code this has
@@ -756,7 +758,9 @@ void TabLifecycleUnitSource::TabLifecycleUnit::FinishDiscard(
   // TODO(jamescook): This breaks script connections with other tabs. Find a
   // different approach that doesn't do that, perhaps based on
   // RenderFrameProxyHosts.
-  old_contents_deleter.reset();
+  // MUON(bridiver): see tab_manager.h
+  g_browser_process->GetTabManager()->DestroyOldContents(
+      std::move(old_contents_deleter));
 
   SetState(LifecycleUnitState::DISCARDED,
            DiscardReasonToStateChangeReason(discard_reason));
@@ -932,6 +936,7 @@ void TabLifecycleUnitSource::TabLifecycleUnit::CheckIfTabIsUsedInBackground(
                                                       decision_details);
   }
 
+/*
   // Do not freeze/discard a tab that has active WebUSB connections.
   if (auto* usb_tab_helper = UsbTabHelper::FromWebContents(web_contents)) {
     if (usb_tab_helper->IsDeviceConnected()) {
@@ -939,6 +944,7 @@ void TabLifecycleUnitSource::TabLifecycleUnit::CheckIfTabIsUsedInBackground(
           DecisionFailureReason::LIVE_STATE_USING_WEB_USB);
     }
   }
+*/
 
   // Do not freeze tabs that are currently using DevTools.
   if (DevToolsWindow::GetInstanceForInspectedWebContents(web_contents)) {
diff --git a/chrome/browser/resource_coordinator/tab_lifecycle_unit_source.cc b/chrome/browser/resource_coordinator/tab_lifecycle_unit_source.cc
index e936f25145075e6882537d6557f5dd3199d225fa..5196f97e858a191e87f1bdf66eb1c6a48a18fefe 100644
--- a/chrome/browser/resource_coordinator/tab_lifecycle_unit_source.cc
+++ b/chrome/browser/resource_coordinator/tab_lifecycle_unit_source.cc
@@ -296,8 +296,9 @@ void TabLifecylesEnterprisePreferenceMonitor::GetPref() {
   // lifecycles feature.
   const PrefService::Preference* pref =
       pref_service_->FindPreference(prefs::kTabLifecyclesEnabled);
-  if (pref->IsManaged() && !pref->GetValue()->GetBool())
-    enabled = false;
+/*  if (pref->IsManaged() && !pref->GetValue()->GetBool())
+    enabled = false; */
+  enabled = false;
 
   callback_.Run(enabled);
 }
diff --git a/chrome/browser/resource_coordinator/tab_manager.cc b/chrome/browser/resource_coordinator/tab_manager.cc
index e1566332f1df8898fe33a9f38270b6129e81fca0..f1abbf2283103392913006051ad63985ae7ae4de 100644
--- a/chrome/browser/resource_coordinator/tab_manager.cc
+++ b/chrome/browser/resource_coordinator/tab_manager.cc
@@ -500,6 +500,19 @@ void TabManager::PurgeBackgroundedTabsIfNeeded() {
   }
 }
 
+// MUON(bridiver): see tab_manager.h
+std::unique_ptr<content::WebContents> TabManager::CreateNullContents(
+    const content::WebContents::CreateParams& params,
+    content::WebContents* old_contents) {
+  return content::WebContents::Create(params);
+}
+
+// MUON(bridiver): see tab_manager.h
+void TabManager::DestroyOldContents(
+    std::unique_ptr<content::WebContents> old_contents) {
+  old_contents.reset();
+}
+
 void TabManager::PauseBackgroundTabOpeningIfNeeded() {
   TRACE_EVENT_INSTANT0("navigation",
                        "TabManager::PauseBackgroundTabOpeningIfNeeded",
diff --git a/chrome/browser/resource_coordinator/tab_manager.h b/chrome/browser/resource_coordinator/tab_manager.h
index faf2db8373233b2c1dc2940867991ed56a78f61a..3f21a1db6cf82c48e3ef6600764fbac2d3c1a506 100644
--- a/chrome/browser/resource_coordinator/tab_manager.h
+++ b/chrome/browser/resource_coordinator/tab_manager.h
@@ -34,6 +34,7 @@
 #include "chrome/browser/ui/browser_tab_strip_tracker.h"
 #include "chrome/browser/ui/tabs/tab_strip_model_observer.h"
 #include "content/public/browser/navigation_throttle.h"
+#include "content/public/browser/web_contents.h"
 #include "ui/gfx/native_widget_types.h"
 
 class GURL;
@@ -95,6 +96,13 @@ class TabManager : public LifecycleUnitObserver,
   TabManager();
   ~TabManager() override;
 
+  // MUON(bridiver): override to create/destroy guests webcontents
+  virtual std::unique_ptr<content::WebContents> CreateNullContents(
+      const content::WebContents::CreateParams& params,
+      content::WebContents* old_contents);
+  virtual void DestroyOldContents(
+      std::unique_ptr<content::WebContents> old_contents);
+
   // Start/Stop the Tab Manager.
   void Start();
   void Stop();
@@ -190,6 +198,7 @@ class TabManager : public LifecycleUnitObserver,
   static bool IsTabRestoredInForeground(content::WebContents* web_contents);
 
  private:
+  friend class GuestTabManager;
   friend class TabManagerStatsCollectorTest;
   friend class TabManagerWithProactiveDiscardExperimentEnabledTest;
 
diff --git a/chrome/browser/ssl/ssl_config_service_manager_pref.cc b/chrome/browser/ssl/ssl_config_service_manager_pref.cc
index de9e4280f1984afd3198b5c8132774cc26ff7e95..54be9a23739ddb16322c0067c7e4da51a2e85b02 100644
--- a/chrome/browser/ssl/ssl_config_service_manager_pref.cc
+++ b/chrome/browser/ssl/ssl_config_service_manager_pref.cc
@@ -254,10 +254,14 @@ SSLConfigServiceManagerPref::GetSSLConfigFromPrefs() const {
 
   // rev_checking_enabled was formerly a user-settable preference, but now
   // it is managed-only.
+#if defined(MUON_CHROMIUM_BUILD)
   if (rev_checking_enabled_.IsManaged())
     config->rev_checking_enabled = rev_checking_enabled_.GetValue();
   else
     config->rev_checking_enabled = false;
+#else
+  config->rev_checking_enabled = rev_checking_enabled_.GetValue();
+#endif
   config->rev_checking_required_local_anchors =
       rev_checking_required_local_anchors_.GetValue();
   config->sha1_local_anchors_enabled = sha1_local_anchors_enabled_.GetValue();
diff --git a/chrome/browser/ui/libgtkui/BUILD.gn b/chrome/browser/ui/libgtkui/BUILD.gn
index de40baffe510aa84b342daa3b6c1b62dc4ae9328..7c25bc1ba20baa24cc6c39ba400241c2531469bc 100644
--- a/chrome/browser/ui/libgtkui/BUILD.gn
+++ b/chrome/browser/ui/libgtkui/BUILD.gn
@@ -65,6 +65,9 @@ template("libgtkui") {
                 "x11_input_method_context_impl_gtk.h",
               ]
 
+    configs -= [ "//build/config/gcc:symbol_visibility_hidden" ]
+    configs += [ "//build/config/gcc:symbol_visibility_default" ]
+
     configs += [
       "//build/config/linux/pangocairo",
       "//build/config/linux:x11",
diff --git a/chrome/browser/usb/usb_tab_helper.cc b/chrome/browser/usb/usb_tab_helper.cc
index cca1c6322d296c93d7d1f09ede5209f5a57031d0..9bebadf8c1de522531dc703407c3d74aa17fcc62 100644
--- a/chrome/browser/usb/usb_tab_helper.cc
+++ b/chrome/browser/usb/usb_tab_helper.cc
@@ -138,10 +138,12 @@ FrameUsbServices* UsbTabHelper::GetFrameUsbService(
 base::WeakPtr<device::usb::PermissionProvider>
 UsbTabHelper::GetPermissionProvider(RenderFrameHost* render_frame_host) {
   FrameUsbServices* frame_usb_services = GetFrameUsbService(render_frame_host);
+#if defined(OS_WIN) && !defined(MUON_CHROMIUM_BUILD)
   if (!frame_usb_services->permission_provider) {
     frame_usb_services->permission_provider.reset(
         new WebUSBPermissionProvider(render_frame_host));
   }
+#endif
   return frame_usb_services->permission_provider->GetWeakPtr();
 }
 
diff --git a/chrome/common/BUILD.gn b/chrome/common/BUILD.gn
index 9a21e268447a0ea984101132329073dca486f6ad..32c5ec793cd44d5f45b3d5ff7bb769aadc62a576 100644
--- a/chrome/common/BUILD.gn
+++ b/chrome/common/BUILD.gn
@@ -497,6 +497,12 @@ static_library("common") {
     ]
     public_deps += [ "//chrome/common:version_header" ]
   }
+
+  if (!muon_chromium_build && enable_extensions) {
+    sources -= [
+      "extensions/chrome_extensions_client.cc",
+    ]
+  }
 }
 
 process_version("version_header") {
diff --git a/chrome/common/chrome_constants.cc b/chrome/common/chrome_constants.cc
index 38f30f6ecd6c2073f4f18922c786b93517cf39e8..6a89b71cc022f71c624e89b34519f6fb5fa70c06 100644
--- a/chrome/common/chrome_constants.cc
+++ b/chrome/common/chrome_constants.cc
@@ -10,11 +10,11 @@
 #define FPL FILE_PATH_LITERAL
 
 #if defined(OS_MACOSX)
-#define CHROMIUM_PRODUCT_STRING "Chromium"
+#define CHROMIUM_PRODUCT_STRING PRODUCT_SHORTNAME_STRING
 #if defined(GOOGLE_CHROME_BUILD)
-#define PRODUCT_STRING "Google Chrome"
+#define PRODUCT_STRING PRODUCT_SHORTNAME_STRING
 #elif defined(CHROMIUM_BUILD)
-#define PRODUCT_STRING "Chromium"
+#define PRODUCT_STRING PRODUCT_SHORTNAME_STRING
 #else
 #error Unknown branding
 #endif
@@ -43,13 +43,13 @@ const char kChromeVersion[] = CHROME_VERSION_STRING;
 
 #if defined(OS_WIN)
 const base::FilePath::CharType kBrowserProcessExecutableNameChromium[] =
-    FPL("chrome.exe");
+    FPL("brave.exe");
 const base::FilePath::CharType kBrowserProcessExecutableName[] =
-    FPL("chrome.exe");
+    FPL("brave.exe");
 const base::FilePath::CharType kHelperProcessExecutableNameChromium[] =
-    FPL("chrome.exe");
+    FPL("brave.exe");
 const base::FilePath::CharType kHelperProcessExecutableName[] =
-    FPL("chrome.exe");
+    FPL("brave.exe");
 #elif defined(OS_MACOSX)
 const base::FilePath::CharType kBrowserProcessExecutableNameChromium[] =
     FPL(CHROMIUM_PRODUCT_STRING);
@@ -61,7 +61,7 @@ const base::FilePath::CharType kHelperProcessExecutableName[] =
     FPL(PRODUCT_STRING " Helper");
 #elif defined(OS_ANDROID)
 // NOTE: Keep it synced with the process names defined in AndroidManifest.xml.
-const base::FilePath::CharType kBrowserProcessExecutableName[] = FPL("chrome");
+const base::FilePath::CharType kBrowserProcessExecutableName[] = FPL(EXECUTABLE_NAME);
 const base::FilePath::CharType kBrowserProcessExecutableNameChromium[] =
     FPL("");
 const base::FilePath::CharType kHelperProcessExecutableName[] =
@@ -69,8 +69,8 @@ const base::FilePath::CharType kHelperProcessExecutableName[] =
 const base::FilePath::CharType kHelperProcessExecutableNameChromium[] = FPL("");
 #elif defined(OS_POSIX)
 const base::FilePath::CharType kBrowserProcessExecutableNameChromium[] =
-    FPL("chrome");
-const base::FilePath::CharType kBrowserProcessExecutableName[] = FPL("chrome");
+    FPL(EXECUTABLE_NAME);
+const base::FilePath::CharType kBrowserProcessExecutableName[] = FPL(EXECUTABLE_NAME);
 // Helper processes end up with a name of "exe" due to execing via
 // /proc/self/exe.  See bug 22703.
 const base::FilePath::CharType kHelperProcessExecutableNameChromium[] =
@@ -80,13 +80,13 @@ const base::FilePath::CharType kHelperProcessExecutableName[] = FPL("exe");
 
 #if defined(OS_WIN)
 const base::FilePath::CharType kBrowserProcessExecutablePathChromium[] =
-    FPL("chrome.exe");
+    FPL("brave.exe");
 const base::FilePath::CharType kBrowserProcessExecutablePath[] =
-    FPL("chrome.exe");
+    FPL("brave.exe");
 const base::FilePath::CharType kHelperProcessExecutablePathChromium[] =
-    FPL("chrome.exe");
+    FPL("brave.exe");
 const base::FilePath::CharType kHelperProcessExecutablePath[] =
-    FPL("chrome.exe");
+    FPL("brave.exe");
 #elif defined(OS_MACOSX)
 const base::FilePath::CharType kBrowserProcessExecutablePathChromium[] =
     FPL(CHROMIUM_PRODUCT_STRING ".app/Contents/MacOS/" CHROMIUM_PRODUCT_STRING);
@@ -98,19 +98,19 @@ const base::FilePath::CharType kHelperProcessExecutablePathChromium[] =
 const base::FilePath::CharType kHelperProcessExecutablePath[] =
     FPL(PRODUCT_STRING " Helper.app/Contents/MacOS/" PRODUCT_STRING " Helper");
 #elif defined(OS_ANDROID)
-const base::FilePath::CharType kBrowserProcessExecutablePath[] = FPL("chrome");
-const base::FilePath::CharType kHelperProcessExecutablePath[] = FPL("chrome");
+const base::FilePath::CharType kBrowserProcessExecutablePath[] = FPL(EXECUTABLE_NAME);
+const base::FilePath::CharType kHelperProcessExecutablePath[] = FPL(EXECUTABLE_NAME);
 const base::FilePath::CharType kBrowserProcessExecutablePathChromium[] =
-    FPL("chrome");
+    FPL(EXECUTABLE_NAME);
 const base::FilePath::CharType kHelperProcessExecutablePathChromium[] =
-    FPL("chrome");
+    FPL(EXECUTABLE_NAME);
 #elif defined(OS_POSIX)
 const base::FilePath::CharType kBrowserProcessExecutablePathChromium[] =
-    FPL("chrome");
-const base::FilePath::CharType kBrowserProcessExecutablePath[] = FPL("chrome");
+    FPL(EXECUTABLE_NAME);
+const base::FilePath::CharType kBrowserProcessExecutablePath[] = FPL(EXECUTABLE_NAME);
 const base::FilePath::CharType kHelperProcessExecutablePathChromium[] =
-    FPL("chrome");
-const base::FilePath::CharType kHelperProcessExecutablePath[] = FPL("chrome");
+    FPL(EXECUTABLE_NAME);
+const base::FilePath::CharType kHelperProcessExecutablePath[] = FPL(EXECUTABLE_NAME);
 #endif  // OS_*
 
 #if defined(OS_MACOSX)
@@ -121,7 +121,7 @@ const base::FilePath::CharType kFrameworkExecutableName[] =
 #endif  // OS_MACOSX
 
 #if defined(OS_WIN)
-const base::FilePath::CharType kBrowserResourcesDll[] = FPL("chrome.dll");
+const base::FilePath::CharType kBrowserResourcesDll[] = FPL("brave.dll");
 const base::FilePath::CharType kStatusTrayWindowClass[] =
     FPL("Chrome_StatusTrayWindow");
 #endif  // defined(OS_WIN)
diff --git a/chrome/common/chrome_paths_mac.mm b/chrome/common/chrome_paths_mac.mm
index 40a4d69c5bb3096be8241a7d2b07509ba2a21603..37a0ece79d26635f7e6d5f7bcfb55839cb6c44ac 100644
--- a/chrome/common/chrome_paths_mac.mm
+++ b/chrome/common/chrome_paths_mac.mm
@@ -38,7 +38,9 @@ NSBundle* OuterAppBundleInternal() {
 
   // From C.app/Contents/Versions/1.2.3.4, go up three steps to get to C.app.
   base::FilePath versioned_dir = chrome::GetVersionedDirectory();
-  base::FilePath outer_app_dir = versioned_dir.DirName().DirName().DirName();
+  // electron uses Frameworks in place of Versions/1.2.3.4
+  // TODO(bridiver) - change this to match chrome
+  base::FilePath outer_app_dir = versioned_dir.DirName().DirName();
   const char* outer_app_dir_c = outer_app_dir.value().c_str();
   NSString* outer_app_dir_ns = [NSString stringWithUTF8String:outer_app_dir_c];
 
diff --git a/chrome/common/chrome_version.h.in b/chrome/common/chrome_version.h.in
index f0a0bcd0098ec31b18bb00588ad8fd11b439fd6f..888572f87a71e6e8444bd6a302343e453aef4287 100644
--- a/chrome/common/chrome_version.h.in
+++ b/chrome/common/chrome_version.h.in
@@ -22,3 +22,5 @@
 // Changelist Information
 
 #define LASTCHANGE_STRING "@LASTCHANGE@"
+
+#define EXECUTABLE_NAME "@EXECUTABLE_NAME@"
diff --git a/chrome/common/importer/edge_importer_utils_win.cc b/chrome/common/importer/edge_importer_utils_win.cc
index c2abd64b2d7c5166c1fdbaaf782974cb4bcc5e53..eb59bbe098dabd0edd3d9d8e24befe1006e56b8b 100644
--- a/chrome/common/importer/edge_importer_utils_win.cc
+++ b/chrome/common/importer/edge_importer_utils_win.cc
@@ -73,7 +73,9 @@ bool IsEdgeFavoritesLegacyMode() {
   // for its favorites.
   if (key.ReadValueDW(L"FavoritesESEEnabled", &ese_enabled) == ERROR_SUCCESS)
     return !ese_enabled;
-  return true;
+  // return true;
+  // No value to read means not legacy mode
+  return false;
 }
 
 bool EdgeImporterCanImport() {
diff --git a/chrome/common/importer/importer_data_types.h b/chrome/common/importer/importer_data_types.h
index 0fc90c62398a93eb89568ce78c8ded2bc9b232b6..50a7d3c0079b7e9c5bc38a4ae3b25eef6d024169 100644
--- a/chrome/common/importer/importer_data_types.h
+++ b/chrome/common/importer/importer_data_types.h
@@ -83,6 +83,7 @@ enum VisitSource {
   VISIT_SOURCE_FIREFOX_IMPORTED = 1,
   VISIT_SOURCE_IE_IMPORTED = 2,
   VISIT_SOURCE_SAFARI_IMPORTED = 3,
+  VISIT_SOURCE_CHROME_IMPORTED = 4,
 };
 
 }  // namespace importer
diff --git a/chrome/common/importer/importer_type.h b/chrome/common/importer/importer_type.h
index c172f8a5bc534465ff4d063a52f9bb510b7e36af..437026ae26eec5dce80edb73929a0fbce870cc37 100644
--- a/chrome/common/importer/importer_type.h
+++ b/chrome/common/importer/importer_type.h
@@ -19,6 +19,8 @@ enum ImporterType {
   TYPE_IE              = 0,
 #endif
   // Value 1 was the (now deleted) Firefox 2 profile importer.
+  // We use it for chrome profile now.
+  TYPE_CHROME          = 1,
   TYPE_FIREFOX         = 2,
 #if defined(OS_MACOSX)
   TYPE_SAFARI          = 3,
diff --git a/chrome/common/importer/profile_import.mojom b/chrome/common/importer/profile_import.mojom
index 625b5ddec268292acf11f3c060c07c336ca1317f..9a88422b66723e3fbd805075ca57cb51ff3e026f 100644
--- a/chrome/common/importer/profile_import.mojom
+++ b/chrome/common/importer/profile_import.mojom
@@ -16,6 +16,9 @@ struct ImportedBookmarkEntry;
 [Native]
 struct ImporterAutofillFormDataEntry;
 
+[Native]
+struct ImportedCookieEntry;
+
 [Native]
 struct SearchEngineInfo;
 
@@ -64,6 +67,8 @@ interface ProfileImportObserver {
   OnAutofillFormDataImportStart(uint32 total_autofill_form_data_entry_count);
   OnAutofillFormDataImportGroup(
       array<ImporterAutofillFormDataEntry> autofill_form_data_entry_group);
+  OnCookiesImportStart(uint32 total_cookies_count);
+  OnCookiesImportGroup(array<ImportedCookieEntry> cookies_group);
   // Windows only:
   OnIE7PasswordReceived(ImporterIE7PasswordInfo importer_password_info);
 };
diff --git a/chrome/common/importer/profile_import.typemap b/chrome/common/importer/profile_import.typemap
index 6283f2bf6871a10f710694772b5da0bc9b70c2ad..d5d1de309cb50eb9f8757d32d0eec3b42d08f9c0 100644
--- a/chrome/common/importer/profile_import.typemap
+++ b/chrome/common/importer/profile_import.typemap
@@ -9,6 +9,7 @@ public_headers = [
   "//chrome/common/importer/importer_data_types.h",
   "//chrome/common/importer/importer_url_row.h",
   "//components/favicon_base/favicon_usage_data.h",
+  "//electron/brave/common/importer/imported_cookie_entry.h",
 ]
 traits_headers =
     [ "//chrome/common/importer/profile_import_process_param_traits.h" ]
@@ -26,4 +27,5 @@ type_mappings = [
   "chrome.mojom.SearchEngineInfo=::importer::SearchEngineInfo",
   "chrome.mojom.SourceProfile=::importer::SourceProfile",
   "chrome.mojom.ImportItem=::importer::ImportItem",
+  "chrome.mojom.ImportedCookieEntry=::ImportedCookieEntry",
 ]
diff --git a/chrome/common/importer/profile_import_process_param_traits_macros.h b/chrome/common/importer/profile_import_process_param_traits_macros.h
index dd005641f4349c017bc65d843d8fe49ec6122f64..07777f1b956cc00ccd679ae88a1c733afa9c74cc 100644
--- a/chrome/common/importer/profile_import_process_param_traits_macros.h
+++ b/chrome/common/importer/profile_import_process_param_traits_macros.h
@@ -23,6 +23,7 @@
 #include "components/favicon_base/favicon_usage_data.h"
 #include "content/public/common/common_param_traits.h"
 #include "ipc/ipc_message_macros.h"
+#include "electron/brave/common/importer/imported_cookie_entry.h"
 
 #if defined(OS_WIN)
 IPC_ENUM_TRAITS_MIN_MAX_VALUE(importer::ImporterType,
@@ -91,4 +92,14 @@ IPC_STRUCT_TRAITS_BEGIN(importer::ImporterIE7PasswordInfo)
   IPC_STRUCT_TRAITS_MEMBER(date_created)
 IPC_STRUCT_TRAITS_END()
 
+IPC_STRUCT_TRAITS_BEGIN(ImportedCookieEntry)
+  IPC_STRUCT_TRAITS_MEMBER(domain)
+  IPC_STRUCT_TRAITS_MEMBER(name)
+  IPC_STRUCT_TRAITS_MEMBER(value)
+  IPC_STRUCT_TRAITS_MEMBER(host)
+  IPC_STRUCT_TRAITS_MEMBER(path)
+  IPC_STRUCT_TRAITS_MEMBER(expiry_date)
+  IPC_STRUCT_TRAITS_MEMBER(secure)
+  IPC_STRUCT_TRAITS_MEMBER(httponly)
+IPC_STRUCT_TRAITS_END()
 #endif  // CHROME_COMMON_IMPORTER_PROFILE_IMPORT_PROCESS_PARAM_TRAITS_MACROS_H_
diff --git a/chrome/common/mac/app_mode_chrome_locator.mm b/chrome/common/mac/app_mode_chrome_locator.mm
index efd272e706ba56b748e4b76b96d76cbd03aa07ac..051851c40e6b721035c6b57ed5b359624d55e525 100644
--- a/chrome/common/mac/app_mode_chrome_locator.mm
+++ b/chrome/common/mac/app_mode_chrome_locator.mm
@@ -80,6 +80,7 @@ bool GetChromeBundleInfo(const base::FilePath& chrome_bundle,
   // on the data in their plist, so encode the framework names here.
   NSDictionary* framework_for_exe = @{
     @"Chromium": @"Chromium",
+    @"Brave": @"Brave",
     @"Google Chrome": @"Google Chrome",
     @"Google Chrome Canary": @"Google Chrome",
   };
diff --git a/chrome/common/media/cdm_host_file_path.cc b/chrome/common/media/cdm_host_file_path.cc
index c6030f417db0ea1aca7f1a618a174ab6bc9cb516..e5537c7551e4e2c3c6d3f69a72d21c5333f773c7 100644
--- a/chrome/common/media/cdm_host_file_path.cc
+++ b/chrome/common/media/cdm_host_file_path.cc
@@ -17,7 +17,7 @@
 #include "chrome/common/chrome_constants.h"
 #endif
 
-#if defined(GOOGLE_CHROME_BUILD)
+#if defined(GOOGLE_CHROME_BUILD) || !defined(MUON_CHROMIUM_BUILD)
 
 namespace {
 
diff --git a/chrome/install_static/user_data_dir.cc b/chrome/install_static/user_data_dir.cc
index b5f779d03cfec8ce1db9354d85020acaa10c3a5b..04db5469f8b3705bbf0c36fe6eef5ce1aeaa3355 100644
--- a/chrome/install_static/user_data_dir.cc
+++ b/chrome/install_static/user_data_dir.cc
@@ -74,6 +74,10 @@ bool GetUserDataDirectoryUsingProcessCommandLine(
 // Unify this with the Browser Distribution code.
 bool GetDefaultUserDataDirectory(const InstallConstants& mode,
                                  std::wstring* result) {
+#if !defined(MUON_CHROMIUM_BUILD)
+  result->append(GetEnvironmentString16(L"CHROME_USER_DATA_DIR"));
+  return true;
+#endif
   // This environment variable should be set on Windows Vista and later
   // (https://msdn.microsoft.com/library/windows/desktop/dd378457.aspx).
   std::wstring user_data_dir = GetEnvironmentString16(L"LOCALAPPDATA");
diff --git a/chrome/installer/util/browser_distribution.cc b/chrome/installer/util/browser_distribution.cc
index 33c105c968dc46b62ab39ee766f1ecce4449c358..9ba97762a3f354dcc56826a7c7a090e19c72f4d4 100644
--- a/chrome/installer/util/browser_distribution.cc
+++ b/chrome/installer/util/browser_distribution.cc
@@ -19,6 +19,10 @@
 #include "chrome/installer/util/l10n_string_util.h"
 #include "chrome/installer/util/non_updating_app_registration_data.h"
 
+#if !defined(MUON_CHROMIUM_BUILD)
+#include "chrome/installer/util/muon_distribution.h"
+#endif
+
 namespace {
 
 // The BrowserDistribution object is never freed.
@@ -54,6 +58,7 @@ BrowserDistribution* BrowserDistribution::GetOrCreateBrowserDistribution(
 BrowserDistribution* BrowserDistribution::GetDistribution() {
   BrowserDistribution* dist = NULL;
 
+#if defined(MUON_CHROMIUM_BUILD)
 #if defined(GOOGLE_CHROME_BUILD)
   dist = GetOrCreateBrowserDistribution<GoogleChromeDistribution>(
       &g_browser_distribution);
@@ -61,7 +66,10 @@ BrowserDistribution* BrowserDistribution::GetDistribution() {
   dist = GetOrCreateBrowserDistribution<BrowserDistribution>(
       &g_browser_distribution);
 #endif
-
+#else
+  dist = GetOrCreateBrowserDistribution<MuonDistribution>(
+      &g_browser_distribution);
+#endif
   return dist;
 }
 
diff --git a/chrome/installer/util/prebuild/create_string_rc.py b/chrome/installer/util/prebuild/create_string_rc.py
index d7734d8883c3e438ece3d509b7bb331931831178..6e6cdda19c271de7e5429db02b3e17b2d676b46f 100755
--- a/chrome/installer/util/prebuild/create_string_rc.py
+++ b/chrome/installer/util/prebuild/create_string_rc.py
@@ -109,6 +109,9 @@ MODE_SPECIFIC_STRINGS = {
     'chromium': [
       'IDS_APP_SHORTCUTS_SUBDIR_NAME',
     ],
+    'brave': [
+      'IDS_APP_SHORTCUTS_SUBDIR_NAME',
+    ],
   },
   'IDS_INBOUND_MDNS_RULE_DESCRIPTION': {
     'google_chrome': [
@@ -120,6 +123,9 @@ MODE_SPECIFIC_STRINGS = {
     'chromium': [
       'IDS_INBOUND_MDNS_RULE_DESCRIPTION',
     ],
+    'brave': [
+      'IDS_INBOUND_MDNS_RULE_DESCRIPTION',
+    ],
   },
   'IDS_INBOUND_MDNS_RULE_NAME': {
     'google_chrome': [
@@ -131,6 +137,9 @@ MODE_SPECIFIC_STRINGS = {
     'chromium': [
       'IDS_INBOUND_MDNS_RULE_NAME',
     ],
+    'brave': [
+      'IDS_INBOUND_MDNS_RULE_NAME',
+    ],
   },
   # In contrast to the strings above, this one (IDS_PRODUCT_NAME) is used
   # throughout Chrome in mode-independent contexts. Within the installer (the
@@ -146,6 +155,9 @@ MODE_SPECIFIC_STRINGS = {
     'chromium': [
       'IDS_PRODUCT_NAME',
     ],
+    'brave': [
+      'IDS_PRODUCT_NAME',
+    ],
   },
 }
 # Note: Update the test expectations in GetBaseMessageIdForMode.GoogleStringIds
diff --git a/chrome/renderer/BUILD.gn b/chrome/renderer/BUILD.gn
index 0a1e5754bb7ad43f9ff7130cdaa2aba0c4b6acd5..13a042811559c77a16b96f7524db3cd7cad139e1 100644
--- a/chrome/renderer/BUILD.gn
+++ b/chrome/renderer/BUILD.gn
@@ -412,6 +412,19 @@ static_library("renderer") {
       "searchbox/searchbox_extension.h",
     ]
   }
+
+  if (!muon_chromium_build) {
+    sources -= [
+      "content_settings_observer.cc",
+      "content_settings_observer.h",
+    ]
+
+    if (enable_extensions) {
+      sources -= [
+        "extensions/chrome_extensions_dispatcher_delegate.cc",
+      ]
+    }
+  }
 }
 
 static_library("test_support") {
diff --git a/chrome/renderer/chrome_content_renderer_client.cc b/chrome/renderer/chrome_content_renderer_client.cc
index 2951ee282f4cf3a9ba3847f3cf59b2437873aaa1..90644ca9f5bc861f11b497509d2a83a3507763c8 100644
--- a/chrome/renderer/chrome_content_renderer_client.cc
+++ b/chrome/renderer/chrome_content_renderer_client.cc
@@ -1505,6 +1505,7 @@ ChromeContentRendererClient::CreateBrowserPluginDelegate(
 #endif
 }
 
+#if 0
 void ChromeContentRendererClient::RecordRappor(const std::string& metric,
                                                const std::string& sample) {
   if (!rappor_recorder_) {
@@ -1522,6 +1523,7 @@ void ChromeContentRendererClient::RecordRapporURL(const std::string& metric,
   }
   rappor_recorder_->RecordRapporURL(metric, url);
 }
+#endif  // 0
 
 void ChromeContentRendererClient::AddImageContextMenuProperties(
     const WebURLResponse& response,
diff --git a/chrome/renderer/chrome_content_renderer_client.h b/chrome/renderer/chrome_content_renderer_client.h
index 5b8b73068b814e4d341722ee1e8688e85edc4e01..2b1ce902796db26cb79ef6d38b3b857fd4df9d57 100644
--- a/chrome/renderer/chrome_content_renderer_client.h
+++ b/chrome/renderer/chrome_content_renderer_client.h
@@ -197,9 +197,9 @@ class ChromeContentRendererClient
       const content::WebPluginInfo& info,
       const std::string& mime_type,
       const GURL& original_url) override;
-  void RecordRappor(const std::string& metric,
-                    const std::string& sample) override;
-  void RecordRapporURL(const std::string& metric, const GURL& url) override;
+  //void RecordRappor(const std::string& metric,
+  //                  const std::string& sample) override;
+  //void RecordRapporURL(const std::string& metric, const GURL& url) override;
   void AddImageContextMenuProperties(
       const blink::WebURLResponse& response,
       bool is_image_in_context_a_placeholder_image,
diff --git a/chrome/renderer/pepper/chrome_renderer_pepper_host_factory.cc b/chrome/renderer/pepper/chrome_renderer_pepper_host_factory.cc
index d63e90b6c5079ab3237c4bad3d5e63ce2f99c657..a11bccc62f9ed847013903a48c826bd8737b5604 100644
--- a/chrome/renderer/pepper/chrome_renderer_pepper_host_factory.cc
+++ b/chrome/renderer/pepper/chrome_renderer_pepper_host_factory.cc
@@ -99,11 +99,11 @@ ChromeRendererPepperHostFactory::CreateResourceHost(
   // time of the corresponding instance's method calls.  Currently these
   // interfaces are available only for whitelisted apps which may not have
   // access to the other private interfaces.
-  switch (message.type()) {
-    case PpapiHostMsg_UMA_Create::ID: {
-      return std::make_unique<PepperUMAHost>(host_, instance, resource);
-    }
-  }
+  // switch (message.type()) {
+  //   case PpapiHostMsg_UMA_Create::ID: {
+  //     return std::make_unique<PepperUMAHost>(host_, instance, resource);
+  //   }
+  // }
 
   return nullptr;
 }
diff --git a/chrome/renderer/worker_content_settings_client.cc b/chrome/renderer/worker_content_settings_client.cc
index 29993973814ea5ffd6bc2d6767a0dc74d79ded58..4a76ff3ad63cfa2489fbcd49dc6e9531f454a807 100644
--- a/chrome/renderer/worker_content_settings_client.cc
+++ b/chrome/renderer/worker_content_settings_client.cc
@@ -29,8 +29,8 @@ WorkerContentSettingsClient::WorkerContentSettingsClient(
       url::Origin(frame->Top()->GetSecurityOrigin()).GetURL();
   allow_running_insecure_content_ = ContentSettingsObserver::Get(render_frame)
                                         ->allow_running_insecure_content();
-  content_setting_rules_ =
-      ContentSettingsObserver::Get(render_frame)->GetContentSettingRules();
+  //content_setting_rules_ =
+  //    ContentSettingsObserver::Get(render_frame)->GetContentSettingRules();
 }
 
 WorkerContentSettingsClient::WorkerContentSettingsClient(
diff --git a/chrome/utility/importer/external_process_importer_bridge.h b/chrome/utility/importer/external_process_importer_bridge.h
index 47109f604cf982e74511749890c6fb1ec9ca98f2..4d25f3ae2ca8704046a787e0fb35cdf83c1f9e8f 100644
--- a/chrome/utility/importer/external_process_importer_bridge.h
+++ b/chrome/utility/importer/external_process_importer_bridge.h
@@ -82,6 +82,7 @@ class ExternalProcessImporterBridge : public ImporterBridge {
 
  private:
   ~ExternalProcessImporterBridge() override;
+  friend class BraveExternalProcessImporterBridge;
 
   // Holds strings needed by the external importer because the resource
   // bundle isn't available to the external process.
diff --git a/chrome/utility/importer/firefox_importer.cc b/chrome/utility/importer/firefox_importer.cc
index e98cc6055ad7f0b5df4b73dacef5972b5efb249b..87a57d3718ef110429729fcaee02bee1da8ec1dd 100644
--- a/chrome/utility/importer/firefox_importer.cc
+++ b/chrome/utility/importer/firefox_importer.cc
@@ -159,14 +159,12 @@ void FirefoxImporter::StartImport(const importer::SourceProfile& source_profile,
   if ((items & importer::PASSWORDS) && !cancelled()) {
     bridge_->NotifyItemStarted(importer::PASSWORDS);
     ImportPasswords();
-    bridge_->NotifyItemEnded(importer::PASSWORDS);
   }
   if ((items & importer::AUTOFILL_FORM_DATA) && !cancelled()) {
     bridge_->NotifyItemStarted(importer::AUTOFILL_FORM_DATA);
     ImportAutofillFormData();
     bridge_->NotifyItemEnded(importer::AUTOFILL_FORM_DATA);
   }
-  bridge_->NotifyEnded();
 }
 
 void FirefoxImporter::ImportHistory() {
diff --git a/chrome/utility/importer/firefox_importer.h b/chrome/utility/importer/firefox_importer.h
index 8c6dafc83d25a697a6ca235faf4e0dc386a8828b..f6465167a32f27c496caaa4015a9cd10d83cd9a5 100644
--- a/chrome/utility/importer/firefox_importer.h
+++ b/chrome/utility/importer/firefox_importer.h
@@ -54,7 +54,9 @@ class FirefoxImporter : public Importer {
 
   using FaviconMap = std::map<int64_t, std::set<GURL>>;
 
+ protected:
   ~FirefoxImporter() override;
+ private:
 
   FRIEND_TEST_ALL_PREFIXES(FirefoxImporterTest, ImportBookmarksV25);
   void ImportBookmarks();
diff --git a/chrome/utility/importer/profile_import_impl.h b/chrome/utility/importer/profile_import_impl.h
index c969cc5c740837d5a73650739e66ed659cb6915a..4855eb232919e71fa8aa2cff4d4dda9a89d3cdd3 100644
--- a/chrome/utility/importer/profile_import_impl.h
+++ b/chrome/utility/importer/profile_import_impl.h
@@ -33,6 +33,7 @@ class ProfileImportImpl : public chrome::mojom::ProfileImport {
   ~ProfileImportImpl() override;
 
  private:
+  friend class BraveProfileImportImpl;
   // chrome::mojom::ProfileImport:
   void StartImport(
       const importer::SourceProfile& source_profile,
diff --git a/chrome/utility/importer/profile_import_service.h b/chrome/utility/importer/profile_import_service.h
index c4c5f83886574956b3abdfa77a07500a2ee6de9e..edbfde3c41a1e38bcdedd09aaa41d8a1ab3ab03b 100644
--- a/chrome/utility/importer/profile_import_service.h
+++ b/chrome/utility/importer/profile_import_service.h
@@ -24,6 +24,7 @@ class ProfileImportService : public service_manager::Service {
                        mojo::ScopedMessagePipeHandle interface_pipe) override;
 
  private:
+  friend class BraveProfileImportService;
   // State needed to manage service lifecycle and lifecycle of bound clients.
   std::unique_ptr<service_manager::ServiceContextRefFactory> ref_factory_;
   service_manager::BinderRegistry registry_;
diff --git a/components/autofill/core/browser/credit_card_save_manager.cc b/components/autofill/core/browser/credit_card_save_manager.cc
index d0aba9954e574f147b48142b497f67879619c06f..951f438f95de992443f21cd084e3e81f42197d8f 100644
--- a/components/autofill/core/browser/credit_card_save_manager.cc
+++ b/components/autofill/core/browser/credit_card_save_manager.cc
@@ -187,12 +187,17 @@ void CreditCardSaveManager::AttemptToOfferCardUploadSave(
 }
 
 bool CreditCardSaveManager::IsCreditCardUploadEnabled() {
+#if defined(MUON_CHROMIUM_BUILD)
   // If observer_for_testing_ is set, assume we are in a browsertest and
   // credit card upload should be enabled by default.
   return observer_for_testing_ ||
          ::autofill::IsCreditCardUploadEnabled(
              client_->GetPrefs(), client_->GetSyncService(),
              client_->GetIdentityManager()->GetPrimaryAccountInfo().email);
+#else
+  // MUON(darkdh): disable creait card upload by default
+  return false;
+#endif
 }
 
 bool CreditCardSaveManager::IsUploadEnabledForNetwork(
diff --git a/components/crash/content/app/breakpad_linux.cc b/components/crash/content/app/breakpad_linux.cc
index a7378204ffaa5586be9789a552de0f2a951ad208..25d0ed3e2b2a13e4c8c939e1dfe14586920f2273 100644
--- a/components/crash/content/app/breakpad_linux.cc
+++ b/components/crash/content/app/breakpad_linux.cc
@@ -87,8 +87,10 @@ namespace breakpad {
 
 namespace {
 
-#if !defined(OS_CHROMEOS)
+#if !defined(OS_CHROMEOS) && defined(MUON_CHROMIUM_BUILD)
 const char kUploadURL[] = "https://clients2.google.com/cr/report";
+#else
+const char kUploadURL[] = "https://laptop-updates.brave.com/1/crashes";
 #endif
 
 bool g_is_crash_reporter_enabled = false;
@@ -1358,6 +1360,7 @@ void ExecUploadProcessOrTerminate(const BreakpadInfo& info,
     header_content_type,
     post_file,
     kUploadURL,
+    "--quiet",
     "--timeout=10",  // Set a timeout so we don't hang forever.
     "--tries=1",     // Don't retry if the upload fails.
     "-O",  // Output reply to the file descriptor path.
@@ -1912,6 +1915,7 @@ void HandleCrashDump(const BreakpadInfo& info) {
 
         const size_t kCrashIdLength = 16;
         char id_buf[kCrashIdLength + 1];
+
         size_t bytes_read =
             WaitForCrashReportUploadProcess(fds[0], kCrashIdLength, id_buf);
         HandleCrashReportId(id_buf, bytes_read, kCrashIdLength);
diff --git a/components/crash/content/app/crashpad_mac.mm b/components/crash/content/app/crashpad_mac.mm
index f06d903c2f41b8a58cfc406c36704ae93bf30378..7eebefa875ebe41e700003e1b75d2edd0a731a4c 100644
--- a/components/crash/content/app/crashpad_mac.mm
+++ b/components/crash/content/app/crashpad_mac.mm
@@ -132,6 +132,8 @@ base::FilePath PlatformCrashpadInitialization(bool initial_client,
       // Only allow the possibility of report upload in official builds. This
       // crash server won't have symbols for any other build types.
       std::string url = "https://clients2.google.com/cr/report";
+#elif !defined(MUON_CHROMIUM_BUILD)
+      std::string url = "https://laptop-updates.brave.com/1/crashes";
 #else
       std::string url;
 #endif
diff --git a/components/crash/content/app/crashpad_win.cc b/components/crash/content/app/crashpad_win.cc
index 8b0edef1b59403f819e3c1b4d3b378f849c68f26..637e32fd295b6bd513b33899414f36c2dac22464 100644
--- a/components/crash/content/app/crashpad_win.cc
+++ b/components/crash/content/app/crashpad_win.cc
@@ -82,6 +82,8 @@ base::FilePath PlatformCrashpadInitialization(bool initial_client,
 
 #if defined(GOOGLE_CHROME_BUILD)
     std::string url = "https://clients2.google.com/cr/report";
+#elif !defined(MUON_CHROMIUM_BUILD)
+    std::string url = "https://laptop-updates.brave.com/1/crashes";
 #else
     std::string url;
 #endif
diff --git a/components/crash/core/browser/resources/crashes.js b/components/crash/core/browser/resources/crashes.js
index dbd2ae8df59756c61d28091cff70098c897db8f4..84fbc695c817c87deb902d8b6f69d3f1ec762ccb 100644
--- a/components/crash/core/browser/resources/crashes.js
+++ b/components/crash/core/browser/resources/crashes.js
@@ -105,9 +105,9 @@ function updateCrashList(
         // https://bugs.chromium.org/p/monorail/issues/detail?id=1488 is done.
         labels: 'Restrict-View-EditIssue,Stability-Crash,User-Submitted',
       };
-      var href = 'https://code.google.com/p/chromium/issues/entry';
+      var href = 'https://github.com/brave/browser-laptop/issues/new';
       for (var param in params) {
-        href = appendParam(href, param, params[param]);
+        // href = appendParam(href, param, params[param]);
       }
       link.href = href;
       link.target = '_blank';
diff --git a/components/guest_view/browser/guest_view_base.cc b/components/guest_view/browser/guest_view_base.cc
index 7b1a30f6189d1c45ac89288d22b61f07d2360f77..e851b27d2dd78d31db8b0c6587fb78067fe75dec 100644
--- a/components/guest_view/browser/guest_view_base.cc
+++ b/components/guest_view/browser/guest_view_base.cc
@@ -418,8 +418,10 @@ void GuestViewBase::DidAttach(int guest_proxy_routing_id) {
 
   SetUpSizing(*attach_params());
 
+#if defined(MUON_CHROMIUM_BUILD)
   // The guest should have the same muting state as the owner.
   web_contents()->SetAudioMuted(owner_web_contents()->IsAudioMuted());
+#endif
 
   // Give the derived class an opportunity to perform some actions.
   DidAttachToEmbedder();
@@ -439,8 +441,12 @@ void GuestViewBase::DidDetach() {
   owner_web_contents()->GetRenderViewHost()->Send(
       new GuestViewMsg_GuestDetached(element_instance_id_));
   element_instance_id_ = kInstanceIDNone;
-  if (ShouldDestroyOnDetach())
+  if (ShouldDestroyOnDetach()) {
     Destroy(true);
+  } else {
+    // Give the derived class an opportunity to perform some actions.
+    DidDetachFromEmbedder();
+  }
 }
 
 WebContents* GuestViewBase::GetOwnerWebContents() const {
diff --git a/components/guest_view/browser/guest_view_base.h b/components/guest_view/browser/guest_view_base.h
index fc5b48c0f9a9f28da8fd68c684f0652b7e1352a7..bca49df25c4d852cbcf83ebc5ff59dbb20870062 100644
--- a/components/guest_view/browser/guest_view_base.h
+++ b/components/guest_view/browser/guest_view_base.h
@@ -243,6 +243,9 @@ class GuestViewBase : public content::BrowserPluginGuestDelegate,
   // an opportunity to perform setup actions after attachment.
   virtual void DidAttachToEmbedder() {}
 
+  // This method is called after the guest has been detached from an embedder
+  virtual void DidDetachFromEmbedder() {}
+
   // This method is called after this GuestViewBase has been initiated.
   //
   // This gives the derived class an opportunity to perform additional
diff --git a/components/guest_view/browser/guest_view_manager.cc b/components/guest_view/browser/guest_view_manager.cc
index 0671c3cd7d7880a79efa3a3bba0d977f24049c3c..1cdb522b62f83f06bf5be8839c7eb53f22d4e044 100644
--- a/components/guest_view/browser/guest_view_manager.cc
+++ b/components/guest_view/browser/guest_view_manager.cc
@@ -67,6 +67,9 @@ class GuestViewManager::EmbedderRenderProcessHostObserver
   int id_;
 };
 
+// static
+GuestViewManager* manager_ = nullptr;
+
 GuestViewManager::GuestViewManager(
     content::BrowserContext* context,
     std::unique_ptr<GuestViewManagerDelegate> delegate)
@@ -90,8 +93,9 @@ GuestViewManager* GuestViewManager::CreateWithDelegate(
     } else {
       guest_manager = new GuestViewManager(context, std::move(delegate));
     }
-    context->SetUserData(kGuestViewManagerKeyName,
-                         base::WrapUnique(guest_manager));
+    manager_ = guest_manager;
+    //context->SetUserData(kGuestViewManagerKeyName,
+    //                     base::WrapUnique(guest_manager));
   }
   return guest_manager;
 }
@@ -99,8 +103,9 @@ GuestViewManager* GuestViewManager::CreateWithDelegate(
 // static
 GuestViewManager* GuestViewManager::FromBrowserContext(
     BrowserContext* context) {
-  return static_cast<GuestViewManager*>(context->GetUserData(
-      kGuestViewManagerKeyName));
+  //return static_cast<GuestViewManager*>(context->GetUserData(
+  //    kGuestViewManagerKeyName));
+  return manager_;
 }
 
 // static
diff --git a/components/os_crypt/key_storage_libsecret.cc b/components/os_crypt/key_storage_libsecret.cc
index a1b5b975bc89c4891643adab17ce0b00ba2a8032..229928f2381eaecf6d3180109dd9aaa7725a010e 100644
--- a/components/os_crypt/key_storage_libsecret.cc
+++ b/components/os_crypt/key_storage_libsecret.cc
@@ -5,6 +5,7 @@
 #include "components/os_crypt/key_storage_libsecret.h"
 
 #include "base/base64.h"
+#include "base/command_line.h"
 #include "base/rand_util.h"
 #include "base/strings/string_number_conversions.h"
 #include "components/os_crypt/libsecret_util_linux.h"
@@ -73,6 +74,12 @@ std::string KeyStorageLibsecret::AddRandomPasswordInLibsecret() {
 
 std::string KeyStorageLibsecret::GetKeyImpl() {
   LibsecretAttributesBuilder attrs;
+  const char *kApplicationName;
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("import-chrome")) {
+    kApplicationName = "chrome";
+  } else {
+    kApplicationName = ::kApplicationName;
+  }
   attrs.Append("application", kApplicationName);
 
   LibsecretLoader::SearchHelper helper;
diff --git a/components/os_crypt/keychain_password_mac.mm b/components/os_crypt/keychain_password_mac.mm
index 7c110c7b14e559cd73dfb0ca6f72c14b671d52b8..dc3e79afa4f9b80f27b1a6026c06543f0d974367 100644
--- a/components/os_crypt/keychain_password_mac.mm
+++ b/components/os_crypt/keychain_password_mac.mm
@@ -7,6 +7,7 @@
 #import <Security/Security.h>
 
 #include "base/base64.h"
+#include "base/command_line.h"
 #include "base/mac/mac_logging.h"
 #include "base/rand_util.h"
 #include "crypto/apple_keychain.h"
@@ -56,6 +57,14 @@ const char KeychainPassword::account_name[] = "Chromium";
 std::string KeychainPassword::GetPassword() const {
   UInt32 password_length = 0;
   void* password_data = NULL;
+  const char *service_name, *account_name;
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("import-chrome")) {
+    service_name = "Chrome Safe Storage";
+    account_name = "Chrome";
+  } else {
+    service_name = ::KeychainPassword::service_name;
+    account_name = ::KeychainPassword::account_name;
+  }
   OSStatus error = keychain_.FindGenericPassword(
       strlen(service_name), service_name, strlen(account_name), account_name,
       &password_length, &password_data, NULL);
diff --git a/components/password_manager/core/browser/new_password_form_manager.cc b/components/password_manager/core/browser/new_password_form_manager.cc
index 36703f51cf95bb7cdc8e1d39e0d6f2da6637d3b2..3664a10c9ff122e907cd528c7d2e971d35536f47 100644
--- a/components/password_manager/core/browser/new_password_form_manager.cc
+++ b/components/password_manager/core/browser/new_password_form_manager.cc
@@ -162,6 +162,12 @@ void NewPasswordFormManager::OnNeverClicked() {}
 void NewPasswordFormManager::OnNoInteraction(bool is_update) {}
 void NewPasswordFormManager::PermanentlyBlacklist() {}
 void NewPasswordFormManager::OnPasswordsRevealed() {}
+#if !defined(MUON_CHROMIUM_BUILD)
+bool NewPasswordFormManager::IsPossibleConfirmPasswordForm() {
+  NOTREACHED();
+  return false;
+}
+#endif
 
 void NewPasswordFormManager::ProcessMatches(
     const std::vector<const PasswordForm*>& non_federated,
diff --git a/components/password_manager/core/browser/new_password_form_manager.h b/components/password_manager/core/browser/new_password_form_manager.h
index 0459cc5e11923d9b815d4bc203b4f03c8bfe7bb2..1b8d73792fb868b9b3e44c6bd2d68d74cb117ec4 100644
--- a/components/password_manager/core/browser/new_password_form_manager.h
+++ b/components/password_manager/core/browser/new_password_form_manager.h
@@ -103,6 +103,10 @@ class NewPasswordFormManager : public PasswordFormManagerForUI,
   void PermanentlyBlacklist() override;
   void OnPasswordsRevealed() override;
 
+#if !defined(MUON_CHROMIUM_BUILD)
+  bool IsPossibleConfirmPasswordForm() override;
+#endif
+
  protected:
   // FormFetcher::Consumer:
   void ProcessMatches(
diff --git a/components/password_manager/core/browser/password_form_manager.cc b/components/password_manager/core/browser/password_form_manager.cc
index 34823967b5f83741bb872fd23f6474e8823192d2..333b7e77cf0330bed8941538eb38a067fa932e1d 100644
--- a/components/password_manager/core/browser/password_form_manager.cc
+++ b/components/password_manager/core/browser/password_form_manager.cc
@@ -17,6 +17,7 @@
 #include "base/metrics/user_metrics.h"
 #include "base/stl_util.h"
 #include "base/strings/string16.h"
+#include "base/strings/utf_string_conversions.h"
 #include "base/strings/string_split.h"
 #include "base/strings/string_util.h"
 #include "base/time/time.h"
@@ -885,6 +886,17 @@ void PasswordFormManager::OnPasswordsRevealed() {
   votes_uploader_.set_has_passwords_revealed_vote(true);
 }
 
+#if !defined(MUON_CHROMIUM_BUILD)
+bool PasswordFormManager::IsPossibleConfirmPasswordForm() {
+  return submitted_form_->new_password_element.empty() &&
+         submitted_form_->layout !=
+             autofill::PasswordForm::Layout::LAYOUT_LOGIN_AND_SIGNUP &&
+         // https://chromium.googlesource.com/chromium/src/+/fdef64500de7e7cdfcc1a77ae7e82ad4a39d264f
+         submitted_form_->username_element ==
+             base::UTF8ToUTF16("anonymous_username");
+}
+#endif
+
 void PasswordFormManager::SetHasGeneratedPassword(bool generated_password) {
   has_generated_password_ = generated_password;
   votes_uploader_.set_has_generated_password(generated_password);
diff --git a/components/password_manager/core/browser/password_form_manager.h b/components/password_manager/core/browser/password_form_manager.h
index 547c46271b167968e660d205d2d9f23ab088b185..5c8e0465265c85e58fb049ff964ea16a4990a48d 100644
--- a/components/password_manager/core/browser/password_form_manager.h
+++ b/components/password_manager/core/browser/password_form_manager.h
@@ -248,6 +248,10 @@ class PasswordFormManager : public PasswordFormManagerForUI,
   void PermanentlyBlacklist() override;
   void OnPasswordsRevealed() override;
 
+#if !defined(MUON_CHROMIUM_BUILD)
+  bool IsPossibleConfirmPasswordForm() override;
+#endif
+
  protected:
   // FormFetcher::Consumer:
   void ProcessMatches(
diff --git a/components/password_manager/core/browser/password_form_manager_for_ui.h b/components/password_manager/core/browser/password_form_manager_for_ui.h
index ac7a6eb8c3298bbf6a25bf3eb623a8875383bc1e..e5383acaae9965d602ce3a46671026eae5904f8b 100644
--- a/components/password_manager/core/browser/password_form_manager_for_ui.h
+++ b/components/password_manager/core/browser/password_form_manager_for_ui.h
@@ -99,6 +99,10 @@ class PasswordFormManagerForUI {
 
   // Called when the passwords were shown on on the bubble without obfuscation.
   virtual void OnPasswordsRevealed() = 0;
+
+#if !defined(MUON_CHROMIUM_BUILD)
+  virtual bool IsPossibleConfirmPasswordForm() = 0;
+#endif
 };
 
 }  // namespace  password_manager
diff --git a/components/viz/client/client_layer_tree_frame_sink.cc b/components/viz/client/client_layer_tree_frame_sink.cc
index c779823dc6427a56577ed1627f816058da808f72..26d285dad796bd55cee9bf1a87712556ce112f21 100644
--- a/components/viz/client/client_layer_tree_frame_sink.cc
+++ b/components/viz/client/client_layer_tree_frame_sink.cc
@@ -129,10 +129,6 @@ void ClientLayerTreeFrameSink::SubmitCompositorFrame(CompositorFrame frame) {
     if (local_surface_id_ == last_submitted_local_surface_id_) {
       CHECK_EQ(last_submitted_device_scale_factor_,
                frame.device_scale_factor());
-      CHECK_EQ(last_submitted_size_in_pixels_.height(),
-               frame.size_in_pixels().height());
-      CHECK_EQ(last_submitted_size_in_pixels_.width(),
-               frame.size_in_pixels().width());
     }
   }
 
diff --git a/content/app/content_main_runner_impl.cc b/content/app/content_main_runner_impl.cc
index 8d789ef1b9f76aacbf1bc8c13b79de04618b9141..5f29cccc1f0af8a1b47666a374e75dc3e05fc9ee 100644
--- a/content/app/content_main_runner_impl.cc
+++ b/content/app/content_main_runner_impl.cc
@@ -835,7 +835,7 @@ int ContentMainRunnerImpl::Initialize(const ContentMainParams& params) {
           return nullptr;
         }));
 
-#if !defined(OFFICIAL_BUILD)
+#if 0
 #if defined(OS_WIN)
     bool should_enable_stack_dump = !process_type.empty();
 #else
@@ -851,7 +851,7 @@ int ContentMainRunnerImpl::Initialize(const ContentMainParams& params) {
             service_manager::switches::kDisableInProcessStackTraces)) {
       base::debug::EnableInProcessStackDumping();
     }
-#endif  // !defined(OFFICIAL_BUILD)
+#endif  // 0
 
     delegate_->PreSandboxStartup();
 
diff --git a/content/browser/browser_plugin/browser_plugin_guest.cc b/content/browser/browser_plugin/browser_plugin_guest.cc
index f56ce93c3d5b1b46b706800a12a21f29cabafb33..745a5f821a3b49f95d0181381b6fa616e7cf7a11 100644
--- a/content/browser/browser_plugin/browser_plugin_guest.cc
+++ b/content/browser/browser_plugin/browser_plugin_guest.cc
@@ -830,6 +830,8 @@ void BrowserPluginGuest::OnDetach(int browser_plugin_instance_id) {
   }
 
   delegate_->DidDetach();
+  // MUON(bbondy): Make sure GetGuestProxyRoutingID gets new info on re-attach
+  guest_proxy_routing_id_ = MSG_ROUTING_NONE;
 }
 
 void BrowserPluginGuest::OnDragStatusUpdate(int browser_plugin_instance_id,
diff --git a/content/browser/find_request_manager.cc b/content/browser/find_request_manager.cc
index 34c5307b0fa70deea728cf36c4dfbf93dc32fc66..8b0ab6f2632e6ef8e8cca6d4eaa8f95d8a0694c6 100644
--- a/content/browser/find_request_manager.cc
+++ b/content/browser/find_request_manager.cc
@@ -87,6 +87,8 @@ FrameTreeNode* GetParent(FrameTreeNode* node) {
   // The parent frame may be in another WebContents.
   if (node->IsMainFrame()) {
     auto* contents = WebContentsImpl::FromFrameTreeNode(node);
+    if (static_cast<WebContentsImpl*>(contents)->GetBrowserPluginGuest())
+      return nullptr;
     if (GuestMode::IsCrossProcessFrameGuest(contents)) {
       int node_id = contents->GetOuterDelegateFrameTreeNodeId();
       if (node_id != FrameTreeNode::kFrameTreeNodeInvalidId)
@@ -651,6 +653,9 @@ RenderFrameHost* FindRequestManager::Traverse(RenderFrameHost* from_rfh,
                                               bool forward,
                                               bool matches_only,
                                               bool wrap) const {
+  if (static_cast<WebContentsImpl*>(contents_)->GetBrowserPluginGuest() &&
+      WebContents::FromRenderFrameHost(from_rfh) != contents_)
+    from_rfh = GetInitialFrame(forward);
   DCHECK(from_rfh);
   FrameTreeNode* node =
       static_cast<RenderFrameHostImpl*>(from_rfh)->frame_tree_node();
diff --git a/content/browser/frame_host/render_frame_host_impl.cc b/content/browser/frame_host/render_frame_host_impl.cc
index 8e5af3e3b9c5b9e5c7a2462600fb2c9582df0c7c..875ea27a1f44a982067aa15f39dd7304a21775e8 100644
--- a/content/browser/frame_host/render_frame_host_impl.cc
+++ b/content/browser/frame_host/render_frame_host_impl.cc
@@ -3192,9 +3192,13 @@ void RenderFrameHostImpl::CreateNewWindow(
     return;
   }
 
+  scoped_refptr<SiteInstance> site_instance =
+    params->opener_suppressed
+      ? SiteInstance::CreateForURL(GetProcess()->GetBrowserContext(), params->target_url)
+      : GetSiteInstance();
   // This will clone the sessionStorage for namespace_id_to_clone.
   StoragePartition* storage_partition = BrowserContext::GetStoragePartition(
-      GetSiteInstance()->GetBrowserContext(), GetSiteInstance());
+      site_instance->GetBrowserContext(), site_instance.get());
   DOMStorageContextWrapper* dom_storage_context =
       static_cast<DOMStorageContextWrapper*>(
           storage_partition->GetDOMStorageContext());
diff --git a/content/browser/frame_host/render_widget_host_view_guest.cc b/content/browser/frame_host/render_widget_host_view_guest.cc
index 7c08ae7a4eeec613d813d20db2ecacc801c9c5cf..159ec6e6f5d2d6462a8c9de0327b010ef7d3895d 100644
--- a/content/browser/frame_host/render_widget_host_view_guest.cc
+++ b/content/browser/frame_host/render_widget_host_view_guest.cc
@@ -601,7 +601,14 @@ void RenderWidgetHostViewGuest::ShowDefinitionForSelection() {
   // overlay (it will open Dictionary.app), so the target NSView need not be
   // specified.
   // https://crbug.com/152438
+#if defined(MUON_CHROMIUM_BUILD)
   platform_view_->ShowDefinitionForSelection();
+#else
+  if (!guest_)
+    return;
+  RenderWidgetHostView* rwhv = guest_->GetOwnerRenderWidgetHostView();
+  platform_view_->ShowDefinitionForSelection(rwhv);
+#endif
 }
 
 void RenderWidgetHostViewGuest::SpeakSelection() {
diff --git a/content/browser/renderer_host/input/synthetic_gesture_target_mac.mm b/content/browser/renderer_host/input/synthetic_gesture_target_mac.mm
index 08d8639f6fd230eaf5fae1e0a94de504b5c76f2f..c1986c9647249d97f3c5dccf48fe90f67e3ca342 100644
--- a/content/browser/renderer_host/input/synthetic_gesture_target_mac.mm
+++ b/content/browser/renderer_host/input/synthetic_gesture_target_mac.mm
@@ -23,7 +23,7 @@
 // Filled with default values.
 @property(readonly) CGFloat deltaX;
 @property(readonly) CGFloat deltaY;
-@property(readonly) NSEventModifierFlags modifierFlags;
+@property(readonly) NSUInteger modifierFlags;
 @property(readonly) NSTimeInterval timestamp;
 
 @end
diff --git a/content/browser/renderer_host/plugin_registry_impl.cc b/content/browser/renderer_host/plugin_registry_impl.cc
index ec071f3b89c16febad73f77a1b17fe864874e371..6c1c79a6d4276d7cf9af7dbc5285dfe1435f313c 100644
--- a/content/browser/renderer_host/plugin_registry_impl.cc
+++ b/content/browser/renderer_host/plugin_registry_impl.cc
@@ -55,6 +55,9 @@ void PluginRegistryImpl::GetPluginsComplete(
   PluginServiceFilter* filter = PluginServiceImpl::GetInstance()->GetFilter();
   std::vector<blink::mojom::PluginInfoPtr> plugins;
 
+
+//  const int child_process_id = render_process_id_;
+// crrev.com/b702474f0f48
   const int child_process_id = -1;
   const int routing_id = MSG_ROUTING_NONE;
   // In this loop, copy the WebPluginInfo (and do not use a reference) because
diff --git a/content/browser/renderer_host/render_process_host_impl.cc b/content/browser/renderer_host/render_process_host_impl.cc
index 184482f37c9d8395e359d58502e9eb8daf21d5cd..902e4affa7412cc97dae3f1d68a9ce8846583912 100644
--- a/content/browser/renderer_host/render_process_host_impl.cc
+++ b/content/browser/renderer_host/render_process_host_impl.cc
@@ -267,6 +267,10 @@
 #define IntToStringType base::IntToString
 #endif
 
+#if !defined(MUON_CHROMIUM_BUILD)
+#include "brave/browser/brave_browser_context.h"
+#endif
+
 namespace content {
 
 using CheckOriginLockResult =
@@ -1354,7 +1358,12 @@ RenderProcessHost* RenderProcessHostImpl::CreateRenderProcessHost(
   // "https://example.com/sw.js" but need to use the site URL
   // "chrome-guest://blahblah" to get a process in the guest's
   // StoragePartition.)
+#if !defined(MUON_CHROMIUM_BUILD)
+  auto brave_browser_context = brave::BraveBrowserContext::FromBrowserContext(browser_context);
+  if ((brave_browser_context->IsIsolatedStorage() || is_for_guests_only) && site_instance &&
+#else
   if (is_for_guests_only && site_instance &&
+#endif
       storage_partition_impl->site_for_service_worker().is_empty()) {
     storage_partition_impl->set_site_for_service_worker(
         site_instance->GetSiteURL());
diff --git a/content/browser/renderer_host/render_widget_host_ns_view_bridge_local.h b/content/browser/renderer_host/render_widget_host_ns_view_bridge_local.h
index a7678f05d794a4ea0498fa698d3b051b8e7e908b..7d4352d4f77c032263f4390d5492f718ee420e77 100644
--- a/content/browser/renderer_host/render_widget_host_ns_view_bridge_local.h
+++ b/content/browser/renderer_host/render_widget_host_ns_view_bridge_local.h
@@ -10,6 +10,9 @@
 #import "base/mac/scoped_nsobject.h"
 #import "content/browser/renderer_host/popup_window_mac.h"
 #import "content/browser/renderer_host/render_widget_host_view_cocoa.h"
+#if !defined(MUON_CHROMIUM_BUILD)
+#include "content/browser/renderer_host/render_widget_host_view_mac.h"
+#endif
 #include "content/common/render_widget_host_ns_view.mojom.h"
 #include "ui/accelerated_widget_mac/display_ca_layer_tree.h"
 #include "ui/display/display_observer.h"
@@ -54,6 +57,12 @@ class RenderWidgetHostNSViewBridgeLocal
   void DisplayCursor(const WebCursor& cursor) override;
   void SetCursorLocked(bool locked) override;
   void ShowDictionaryOverlayForSelection() override;
+#if !defined(MUON_CHROMIUM_BUILD)
+  void ShowDictionaryOverlayForSelection(RenderWidgetHostView* target_view);
+/*  void SetTargetView(RenderWidgetHostView* target_view) override {
+    target_view_ = static_cast<RenderWidgetHostViewMac*>(target_view);
+  }; */
+#endif
   void ShowDictionaryOverlay(
       const mac::AttributedStringCoder::EncodedString& encoded_string,
       const gfx::Point& baseline_point) override;
@@ -91,6 +100,10 @@ class RenderWidgetHostNSViewBridgeLocal
   // Cached copy of the tooltip text, to avoid redundant calls.
   base::string16 tooltip_text_;
 
+#if !defined(MUON_CHROMIUM_BUILD)
+  RenderWidgetHostViewMac* target_view_;
+#endif
+
   DISALLOW_COPY_AND_ASSIGN(RenderWidgetHostNSViewBridgeLocal);
 };
 
diff --git a/content/browser/renderer_host/render_widget_host_ns_view_bridge_local.mm b/content/browser/renderer_host/render_widget_host_ns_view_bridge_local.mm
index 9df5543cc218f073d65ab153a66a4cb1c80657fa..47532c173d1da797b122e8ae1c1c37473cb952a3 100644
--- a/content/browser/renderer_host/render_widget_host_ns_view_bridge_local.mm
+++ b/content/browser/renderer_host/render_widget_host_ns_view_bridge_local.mm
@@ -29,6 +29,10 @@ RenderWidgetHostNSViewBridgeLocal::RenderWidgetHostNSViewBridgeLocal(
       std::make_unique<ui::DisplayCALayerTree>(background_layer_.get());
   [cocoa_view_ setLayer:background_layer_];
   [cocoa_view_ setWantsLayer:YES];
+#if !defined(MUON_CHROMIUM_BUILD)
+  target_view_ = NULL;
+#endif
+
 }
 
 RenderWidgetHostNSViewBridgeLocal::~RenderWidgetHostNSViewBridgeLocal() {
@@ -225,10 +229,17 @@ void RenderWidgetHostNSViewBridgeLocal::ShowDictionaryOverlay(
       mac::AttributedStringCoder::Decode(&encoded_string);
   if ([string length] == 0)
     return;
+  NSView* view = cocoa_view_;
+#if !defined(MUON_CHROMIUM_BUILD)
+  if (target_view_) {
+    view = target_view_->cocoa_view();
+  }
+#endif
+
   NSPoint flipped_baseline_point = {
-      baseline_point.x(), [cocoa_view_ frame].size.height - baseline_point.y(),
+      baseline_point.x(), [view frame].size.height - baseline_point.y(),
   };
-  [cocoa_view_ showDefinitionForAttributedString:string
+  [view showDefinitionForAttributedString:string
                                          atPoint:flipped_baseline_point];
 }
 
diff --git a/content/browser/renderer_host/render_widget_host_view_aura.cc b/content/browser/renderer_host/render_widget_host_view_aura.cc
index 09168578786f9ecfa3e1c44b134d7fe76af9504c..b5e50b693ef29a6afd9e16c8a8a1a94b4792d363 100644
--- a/content/browser/renderer_host/render_widget_host_view_aura.cc
+++ b/content/browser/renderer_host/render_widget_host_view_aura.cc
@@ -1638,8 +1638,23 @@ bool RenderWidgetHostViewAura::TransformPointToLocalCoordSpaceLegacy(
       !delegated_frame_host_->TransformPointToLocalCoordSpaceLegacy(
           point_in_pixels, original_surface, transformed_point))
     return false;
-  *transformed_point =
-      gfx::ConvertPointToDIP(device_scale_factor_, *transformed_point);
+
+  // MUON(bbondy): When the point hasn't changed, avoid the double floor
+  // convert from pixels to DIP, which can change the input point from a
+  // couple of pixels. This can cause problems for other parts in the code
+  // like SelectionController which does an exact point comparison.  The
+  // double conversion causes a problem in particular when the DPI is not a
+  // multiple of 100.
+  // For example at 175% DPI 21 * 1.75 = 36.75, floored gives 36.
+  // Then the second DIP convert: 36 / 1.75 = 20.57, floored gives 20.
+  // Same point but we lost a pixel in that case.
+  // See: https://github.com/brave/browser-laptop/issues/8472
+  if (point_in_pixels == *transformed_point) {
+    *transformed_point = point;
+  } else {
+    *transformed_point =
+        gfx::ConvertPointToDIP(device_scale_factor_, *transformed_point);
+  }
   return true;
 }
 
diff --git a/content/browser/renderer_host/render_widget_host_view_cocoa.mm b/content/browser/renderer_host/render_widget_host_view_cocoa.mm
index 8b84322baa808f66044361d1033ec63805856227..956e4851aa8a9371e972d7f4307b72d356737172 100644
--- a/content/browser/renderer_host/render_widget_host_view_cocoa.mm
+++ b/content/browser/renderer_host/render_widget_host_view_cocoa.mm
@@ -174,6 +174,12 @@ void ExtractUnderlines(NSAttributedString* string,
 
 }  // namespace
 
+#ifndef MUON_CHROMIUM_BUILD
+@interface NSWindow (AtomCustomMethods)
+- (BOOL)acceptsFirstMouse;
+- (BOOL)disableAutoHideCursor;
+@end
+#endif
 // These are not documented, so use only after checking -respondsToSelector:.
 @interface NSApplication (UndocumentedSpeechMethods)
 - (void)speakString:(NSString*)string;
@@ -354,7 +360,14 @@ void ExtractUnderlines(NSAttributedString* string,
 }
 
 - (BOOL)acceptsFirstMouse:(NSEvent*)theEvent {
+#ifdef MUON_CHROMIUM_BUILD
   return [self acceptsMouseEventsWhenInactive];
+#else
+  if ([self.window respondsToSelector:@selector(acceptsFirstMouse)] &&
+      [self.window acceptsFirstMouse])
+    return YES;
+  return NO;
+#endif  // MUON_CHROMIUM_BUILD
 }
 
 - (void)setCloseOnDeactivate:(BOOL)b {
@@ -687,6 +700,12 @@ void ExtractUnderlines(NSAttributedString* string,
   bool shouldAutohideCursor = textInputType_ != ui::TEXT_INPUT_TYPE_NONE &&
                               eventType == NSKeyDown &&
                               !(modifierFlags & NSCommandKeyMask);
+#ifndef MUON_CHROMIUM_BUILD
+  shouldAutohideCursor =
+      !([self.window respondsToSelector:@selector(disableAutoHideCursor)] &&
+        [self.window disableAutoHideCursor]) &&
+      shouldAutohideCursor;
+#endif  // MUON_CHROMIUM_BUILD
 
   // We only handle key down events and just simply forward other events.
   if (eventType != NSKeyDown) {
diff --git a/content/browser/renderer_host/render_widget_host_view_mac.h b/content/browser/renderer_host/render_widget_host_view_mac.h
index 052bcb2791c9090df5aa15ee475c2651b7b88259..bb662a3e7ae328630ef4e86f4ccbd6bced0ef50e 100644
--- a/content/browser/renderer_host/render_widget_host_view_mac.h
+++ b/content/browser/renderer_host/render_widget_host_view_mac.h
@@ -109,6 +109,9 @@ class CONTENT_EXPORT RenderWidgetHostViewMac
   bool IsMouseLocked() override;
   void SetActive(bool active) override;
   void ShowDefinitionForSelection() override;
+#if !defined(MUON_CHROMIUM_BUILD)
+  void ShowDefinitionForSelection(RenderWidgetHostView* target_view) override;
+#endif
   void SpeakSelection() override;
   void SetNeedsBeginFrames(bool needs_begin_frames) override;
   void GetScreenInfo(ScreenInfo* screen_info) const override;
diff --git a/content/browser/renderer_host/render_widget_host_view_mac.mm b/content/browser/renderer_host/render_widget_host_view_mac.mm
index 0703dd02c90106a541acf173ec770e18e01c8841..5c16d52e1fafbfb2dbabcc07c4b144cdbb90a7b5 100644
--- a/content/browser/renderer_host/render_widget_host_view_mac.mm
+++ b/content/browser/renderer_host/render_widget_host_view_mac.mm
@@ -1262,6 +1262,10 @@ void RenderWidgetHostViewMac::SetActive(bool active) {
   if (host()) {
     host()->SetActive(active);
     if (active) {
+      // RenderWidgetHostViewGuest doesn't send Show/Hide to the platform_view so
+      // make sure the browser compositor is activated for guest views
+      // when the host is initially hidden
+      browser_compositor_->SetRenderWidgetHostIsHidden(false);
       if (HasFocus())
         host()->Focus();
     } else {
@@ -1279,6 +1283,14 @@ void RenderWidgetHostViewMac::ShowDefinitionForSelection() {
   ns_view_bridge_->ShowDictionaryOverlayForSelection();
 }
 
+#if !defined(MUON_CHROMIUM_BUILD)
+void RenderWidgetHostViewMac::ShowDefinitionForSelection(
+    RenderWidgetHostView* target_view) {
+/*  ns_view_bridge_->SetTargetView(target_view); */
+  ShowDefinitionForSelection();
+}
+#endif
+
 void RenderWidgetHostViewMac::UpdateBackgroundColor() {
   // This is called by the embedding code prior to the first frame appearing,
   // to set a reasonable color to show before the web content generates its
diff --git a/content/browser/renderer_host/render_widget_targeter.cc b/content/browser/renderer_host/render_widget_targeter.cc
index 4a5acc5f53bfe872a605b7fe289e60c478b620ba..ded4e8573213cebd05333d2f2b71102f2b2853e9 100644
--- a/content/browser/renderer_host/render_widget_targeter.cc
+++ b/content/browser/renderer_host/render_widget_targeter.cc
@@ -6,6 +6,7 @@
 
 #include "base/metrics/histogram_functions.h"
 #include "base/metrics/histogram_macros.h"
+#include "content/browser/renderer_host/cursor_manager.h"
 #include "content/browser/renderer_host/input/one_shot_timeout_monitor.h"
 #include "content/browser/renderer_host/render_widget_host_impl.h"
 #include "content/browser/renderer_host/render_widget_host_view_base.h"
@@ -156,7 +157,13 @@ void RenderWidgetTargeter::FindTargetAndDispatch(
   // TODO(kenrb, wjmaclean): Asynchronous hit tests don't work properly with
   // GuestViews, so rely on the synchronous result.
   // See https://crbug.com/802378.
-  if (result.should_query_view && !target->IsRenderWidgetHostViewGuest()) {
+  // TODO(darkdh): MUON - remove this hack when we fully migrate to OOPIF from
+  // legacy guest webvie
+  if (result.should_query_view && (
+      !target->IsRenderWidgetHostViewGuest() ||
+      event.GetType() == blink::WebInputEvent::kMouseMove ||
+      event.GetType() == blink::WebInputEvent::kMouseDown ||
+      event.GetType() == blink::WebInputEvent::kMouseUp)) {
     // TODO(kenrb, sadrul): When all event types support asynchronous hit
     // testing, we should be able to have FindTargetSynchronously return the
     // view and location to use for the renderer hit test query.
@@ -169,6 +176,9 @@ void RenderWidgetTargeter::FindTargetAndDispatch(
     FoundTarget(root_view, target, *event_ptr, latency, result.target_location,
                 result.latched_target);
   }
+  if (root_view->GetCursorManager() &&
+      event.GetType() == blink::WebInputEvent::kMouseMove)
+    root_view->GetCursorManager()->UpdateViewUnderCursor(target);
 }
 
 void RenderWidgetTargeter::ViewWillBeDestroyed(RenderWidgetHostViewBase* view) {
diff --git a/content/browser/storage_partition_impl_map.h b/content/browser/storage_partition_impl_map.h
index ce0951bacd4dab08db92f6a87087279fcc7e4f09..10c7976815635c945079344e63ecf7f9f9932eaf 100644
--- a/content/browser/storage_partition_impl_map.h
+++ b/content/browser/storage_partition_impl_map.h
@@ -22,6 +22,10 @@ class FilePath;
 class SequencedTaskRunner;
 }  // namespace base
 
+namespace brave {
+class BraveBrowserContext;
+} // namespace brave
+
 namespace content {
 
 class BrowserContext;
@@ -64,6 +68,8 @@ class CONTENT_EXPORT StoragePartitionImplMap
   FRIEND_TEST_ALL_PREFIXES(StoragePartitionConfigTest, OperatorLess);
   FRIEND_TEST_ALL_PREFIXES(StoragePartitionImplMapTest, GarbageCollect);
 
+  friend class brave::BraveBrowserContext;
+
   // Each StoragePartition is uniquely identified by which partition domain
   // it belongs to (such as an app or the browser itself), the user supplied
   // partition name and the bit indicating whether it should be persisted on
diff --git a/content/browser/utility_process_host.cc b/content/browser/utility_process_host.cc
index 9d7c9791bd99c361a9ba3edc539d9b48b46659d4..13f6be5b17ce58e0f15464734fee5967c54d7148 100644
--- a/content/browser/utility_process_host.cc
+++ b/content/browser/utility_process_host.cc
@@ -341,6 +341,8 @@ bool UtilityProcessHost::StartProcess() {
     if (is_service) {
       GetContentClient()->browser()->AdjustUtilityServiceProcessCommandLine(
           *service_identity_, cmd_line.get());
+      if (service_identity_->name() == "tor_launcher")
+        cmd_line->AppendSwitch("tor-launcher");
     }
 
     process_->Launch(std::make_unique<UtilitySandboxedProcessLauncherDelegate>(
diff --git a/content/browser/web_contents/web_contents_impl.cc b/content/browser/web_contents/web_contents_impl.cc
index 26384f823b511ca720ae474e950d75fd19b65111..8307b6b098182e3ed6ef9693ae736843f3d8b478 100644
--- a/content/browser/web_contents/web_contents_impl.cc
+++ b/content/browser/web_contents/web_contents_impl.cc
@@ -1885,8 +1885,9 @@ void WebContentsImpl::Init(const WebContents::CreateParams& params) {
   // This is set before initializing the render manager since
   // RenderFrameHostManager::Init calls back into us via its delegate to ask if
   // it should be hidden.
-  visibility_ =
-      params.initially_hidden ? Visibility::HIDDEN : Visibility::VISIBLE;
+  // visibility_ =
+  //     params.initially_hidden ? Visibility::HIDDEN : Visibility::VISIBLE;
+  visibility_ = Visibility::VISIBLE;
 
   if (!params.last_active_time.is_null())
     last_active_time_ = params.last_active_time;
@@ -2567,7 +2568,8 @@ void WebContentsImpl::CreateNewWindow(
   DCHECK(!params.opener_suppressed || render_view_route_id == MSG_ROUTING_NONE);
 
   scoped_refptr<SiteInstance> site_instance =
-      params.opener_suppressed && !is_guest
+      // params.opener_suppressed && !is_guest
+      params.opener_suppressed
           ? SiteInstance::CreateForURL(GetBrowserContext(), params.target_url)
           : source_site_instance;
 
diff --git a/content/browser/web_contents/web_contents_view_mac.mm b/content/browser/web_contents/web_contents_view_mac.mm
index 94848b568363216ae0954b8b6c42cdafdb2a2a72..65431242004122bb54c6fc6b34cac8ce27397121 100644
--- a/content/browser/web_contents/web_contents_view_mac.mm
+++ b/content/browser/web_contents/web_contents_view_mac.mm
@@ -600,6 +600,7 @@ void WebContentsViewMac::SetParentUiLayer(ui::Layer* parent_ui_layer) {
              endedAt:(NSPoint)screenPoint
            operation:(NSDragOperation)operation {
   [dragSource_ endDragAt:screenPoint operation:operation];
+  [dragDest_ endDrag];
 
   // Might as well throw out this object now.
   dragSource_.reset();
diff --git a/content/browser/web_contents/web_drag_dest_mac.h b/content/browser/web_contents/web_drag_dest_mac.h
index c81c2a89ab8ea8c0018a6eecfdcf21219f1b0d8d..fa09b9cd19ddacf5b73d07560405fd06837b6920 100644
--- a/content/browser/web_contents/web_drag_dest_mac.h
+++ b/content/browser/web_contents/web_drag_dest_mac.h
@@ -95,6 +95,9 @@ GetRenderWidgetHostAtPoint:(const NSPoint&)viewPoint
 // Sets |dragStartProcessID_| and |dragStartViewID_|.
 - (void)setDragStartTrackersForProcess:(int)processID;
 
+// Ends a drag operation
+- (void)endDrag;
+
 // Returns whether |targetRWH| is a valid RenderWidgetHost to be dragging
 // over. This enforces that same-page, cross-site drags are not allowed. See
 // crbug.com/666858.
diff --git a/content/browser/web_contents/web_drag_dest_mac.mm b/content/browser/web_contents/web_drag_dest_mac.mm
index cec3bd8a97b8b9bcab176a9bd2c296ec12aba838..a00a391c96fc1f04be189c41cb285a66772260e8 100644
--- a/content/browser/web_contents/web_drag_dest_mac.mm
+++ b/content/browser/web_contents/web_drag_dest_mac.mm
@@ -347,6 +347,12 @@ GetRenderWidgetHostAtPoint:(const NSPoint&)viewPoint
   dragStartViewID_ = GetRenderViewHostID(webContents_->GetRenderViewHost());
 }
 
+- (void)endDrag {
+  dragStartProcessID_ = content::ChildProcessHost::kInvalidUniqueID;
+  dragStartViewID_ = content::GlobalRoutingID(
+    content::ChildProcessHost::kInvalidUniqueID, MSG_ROUTING_NONE);
+}
+
 - (bool)isValidDragTarget:(content::RenderWidgetHostImpl*)targetRWH {
   return targetRWH->GetProcess()->GetID() == dragStartProcessID_ ||
          GetRenderViewHostID(webContents_->GetRenderViewHost()) !=
diff --git a/content/child/child_thread_impl.cc b/content/child/child_thread_impl.cc
index 53f41fc6b2af7050dbab1fa9e651502a4c2707f4..ebb4cfcd1cbad81c43a79e504908bfa540b24cdd 100644
--- a/content/child/child_thread_impl.cc
+++ b/content/child/child_thread_impl.cc
@@ -547,6 +547,7 @@ void ChildThreadImpl::Init(const Options& options) {
   // Check that --process-type is specified so we don't do this in unit tests
   // and single-process mode.
   if (base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kProcessType))
+    if (!base::CommandLine::ForCurrentProcess()->HasSwitch("tor-launcher"))
     channel_->AddFilter(new SuicideOnChannelErrorFilter());
 #endif
 
diff --git a/content/common/content_switches_internal.cc b/content/common/content_switches_internal.cc
index 27c25d3d25e18d9591b6ffd770fcd11875b231f7..01d2b4c88bf1c6f25441f7cd219e56df401f18f6 100644
--- a/content/common/content_switches_internal.cc
+++ b/content/common/content_switches_internal.cc
@@ -115,7 +115,7 @@ void WaitForDebugger(const std::string& label) {
 #if defined(GOOGLE_CHROME_BUILD)
   std::string title = "Google Chrome";
 #else   // CHROMIUM_BUILD
-  std::string title = "Chromium";
+  std::string title = "Brave";
 #endif  // CHROMIUM_BUILD
   title += " ";
   title += label;  // makes attaching to process easier
diff --git a/content/common/dom_storage/dom_storage_map.cc b/content/common/dom_storage/dom_storage_map.cc
index fd088fb170bead6452ded14016f21f0c29659e03..2d51cbc6c9b58263a345b7d641f8d89e7e292523 100644
--- a/content/common/dom_storage/dom_storage_map.cc
+++ b/content/common/dom_storage/dom_storage_map.cc
@@ -187,8 +187,8 @@ bool DOMStorageMap::SetItemInternal(MapType* map_type,
 
   // Only check quota if the size is increasing, this allows
   // shrinking changes to pre-existing files that are over budget.
-  if (new_item_size > old_item_size && new_storage_used > quota_)
-    return false;
+  // if (new_item_size > old_item_size && new_storage_used > quota_)
+  //   return false;
 
   (*map_type)[key] = value;
   ResetKeyIterator();
diff --git a/content/public/app/mojo/content_renderer_manifest.json b/content/public/app/mojo/content_renderer_manifest.json
index 70c678203f239b6c3e1ad5167d46473f1e953240..10378d20d6684708a67aeab91da88f35e85a6e67 100644
--- a/content/public/app/mojo/content_renderer_manifest.json
+++ b/content/public/app/mojo/content_renderer_manifest.json
@@ -49,6 +49,7 @@
     "navigation:frame": {
       "provides": {
         "browser": [
+          "autofill.mojom.AutofillAgent",
           "blink.mojom.AppBannerController",
           "blink.mojom.EngagementClient",
           "blink.mojom.InstallationService",
diff --git a/content/public/browser/render_widget_host_view.h b/content/public/browser/render_widget_host_view.h
index c4b21150bbcf875e59945f3e9df96a32d34ca670..c352243add5392b8347bcfbd4c632f1b8abf555c 100644
--- a/content/public/browser/render_widget_host_view.h
+++ b/content/public/browser/render_widget_host_view.h
@@ -259,6 +259,9 @@ class CONTENT_EXPORT RenderWidgetHostView {
 
   // Brings up the dictionary showing a definition for the selected text.
   virtual void ShowDefinitionForSelection() = 0;
+#if !defined(MUON_CHROMIUM_BUILD)
+  virtual void ShowDefinitionForSelection(RenderWidgetHostView* view) {};
+#endif
 
   // Tells the view to speak the currently selected text.
   virtual void SpeakSelection() = 0;
diff --git a/content/renderer/browser_plugin/browser_plugin.cc b/content/renderer/browser_plugin/browser_plugin.cc
index 4d8251069ae9a45e1be22fa03f23b3196116b612..970eb343c09d03065310c1ad1c11dcb8e7ceb4ea 100644
--- a/content/renderer/browser_plugin/browser_plugin.cc
+++ b/content/renderer/browser_plugin/browser_plugin.cc
@@ -105,6 +105,7 @@ BrowserPlugin::BrowserPlugin(
     delegate_->SetElementInstanceID(browser_plugin_instance_id_);
 
   enable_surface_synchronization_ = features::IsSurfaceSynchronizationEnabled();
+  enable_surface_synchronization_ = false;
 }
 
 BrowserPlugin::~BrowserPlugin() {
@@ -219,7 +220,12 @@ void BrowserPlugin::Detach() {
 
   attached_ = false;
   guest_crashed_ = false;
-  embedded_layer_ = nullptr;
+  // embedded_layer_ = nullptr;
+  compositing_helper_->SetPrimarySurfaceId(
+      viz::SurfaceId(), screen_space_rect().size(),
+      cc::DeadlinePolicy::UseDefaultDeadline());
+  compositing_helper_->SetFallbackSurfaceId(viz::SurfaceId(),
+                                            screen_space_rect().size());
 
   BrowserPluginManager::Get()->Send(
       new BrowserPluginHostMsg_Detach(browser_plugin_instance_id_));
@@ -668,8 +674,6 @@ blink::WebInputEventResult BrowserPlugin::HandleInputEvent(
 
   if (blink::WebInputEvent::IsGestureEventType(event.GetType())) {
     auto gesture_event = static_cast<const blink::WebGestureEvent&>(event);
-    DCHECK(blink::WebInputEvent::kGestureTapDown == event.GetType() ||
-           gesture_event.resending_plugin_id == browser_plugin_instance_id_);
 
     // We shouldn't be forwarding GestureEvents to the Guest anymore. Indicate
     // we handled this only if it's a non-resent event.
diff --git a/extensions/browser/BUILD.gn b/extensions/browser/BUILD.gn
index bde743375f7aa09e3f8c295e5fe5ba0ece42a485..fa5ab4dd75840bfddc0147f14955f063e73f64ed 100644
--- a/extensions/browser/BUILD.gn
+++ b/extensions/browser/BUILD.gn
@@ -329,8 +329,8 @@ jumbo_source_set("browser_sources") {
     "service_worker_task_queue.h",
     "service_worker_task_queue_factory.cc",
     "service_worker_task_queue_factory.h",
-    "shared_user_script_master.cc",
-    "shared_user_script_master.h",
+    #"shared_user_script_master.cc",
+    #"shared_user_script_master.h",
     "state_store.cc",
     "state_store.h",
     "suggest_permission_util.cc",
diff --git a/extensions/browser/api/messaging/message_service.cc b/extensions/browser/api/messaging/message_service.cc
index 3e609a7faf73faa7e578c9cfb6826f600aa3b13c..a07e5837f48ad657bbe0fa7d816fe39dcde3ad8e 100644
--- a/extensions/browser/api/messaging/message_service.cc
+++ b/extensions/browser/api/messaging/message_service.cc
@@ -152,6 +152,11 @@ namespace {
 static content::RenderProcessHost* GetExtensionProcess(
     BrowserContext* context,
     const std::string& extension_id) {
+  auto original = ExtensionsBrowserClient::Get()->GetOriginalContext(context);
+  // Always use the original context for non-private child contexts
+  if (!context->IsOffTheRecord()) {
+    context = original;
+  }
   scoped_refptr<SiteInstance> site_instance =
       ProcessManager::Get(context)->GetSiteInstanceForURL(
           Extension::GetBaseURLFromExtensionId(extension_id));
diff --git a/extensions/browser/guest_view/extensions_guest_view_manager_delegate.cc b/extensions/browser/guest_view/extensions_guest_view_manager_delegate.cc
index ffa79cf2918bc0c651448cb27bebcb780f9c4e6c..5f78f790bccf27fc2349d95324cf1a4f314827a1 100644
--- a/extensions/browser/guest_view/extensions_guest_view_manager_delegate.cc
+++ b/extensions/browser/guest_view/extensions_guest_view_manager_delegate.cc
@@ -63,8 +63,10 @@ void ExtensionsGuestViewManagerDelegate::DispatchEvent(
   // extensions::events::HistogramValue as an argument.
   events::HistogramValue histogram_value =
       guest_view_events::GetEventHistogramValue(event_name);
+#ifdef MUON_CHROMIUM_BUILD
   DCHECK_NE(events::UNKNOWN, histogram_value) << "Event " << event_name
                                               << " must have a histogram value";
+#endif
 
   content::WebContents* owner = guest->owner_web_contents();
   if (!owner)
diff --git a/extensions/browser/guest_view/web_view/web_view_guest.cc b/extensions/browser/guest_view/web_view/web_view_guest.cc
index 0121a18ddef5cb744bcabc2838d2891690a9bce3..a9b11454e77701258e50dead3d58d6ebfc1c3dff 100644
--- a/extensions/browser/guest_view/web_view/web_view_guest.cc
+++ b/extensions/browser/guest_view/web_view/web_view_guest.cc
@@ -306,7 +306,7 @@ std::string WebViewGuest::GetPartitionID(
 }
 
 // static
-const char WebViewGuest::Type[] = "webview";
+const char WebViewGuest::Type[] = "chrome-webview";
 
 // static
 int WebViewGuest::GetOrGenerateRulesRegistryID(
diff --git a/extensions/common/BUILD.gn b/extensions/common/BUILD.gn
index d8d9299b229f48a21897fe2c8b3f5db3711aacf6..c0a86aea18e5ea2ecb528acc992581f13c33b934 100644
--- a/extensions/common/BUILD.gn
+++ b/extensions/common/BUILD.gn
@@ -318,6 +318,7 @@ if (enable_extensions) {
       "//components/url_formatter",
       "//components/url_matcher",
       "//components/version_info",
+      "//content/public/common",
       "//crypto",
       "//device/bluetooth",
       "//device/usb",
diff --git a/extensions/common/api/_api_features.json b/extensions/common/api/_api_features.json
index c0eb07872f0c837cdbaf350e4f81bc473bf60c5e..9fe594db0c5494bc0e7de2fdf4b6dfb032950aae 100644
--- a/extensions/common/api/_api_features.json
+++ b/extensions/common/api/_api_features.json
@@ -193,7 +193,10 @@
     {
       "internal": true,
       "channel": "stable",
-      "contexts": ["blessed_extension"]
+      "contexts": ["blessed_extension", "webui"],
+      "matches": [
+        "chrome://brave/*"
+      ]
     }, {
       "internal": true,
       "channel": "stable",
@@ -566,6 +569,7 @@
     "internal": true,
     "contexts": ["webui"],
     "matches": [
+      "chrome://brave/*",
       "chrome://chrome-signin/*",
       "chrome://home/*",
       "chrome://media-router/*",
@@ -583,6 +587,7 @@
     "channel": "stable",
     "contexts": ["webui"],
     "matches": [
+      "chrome://brave/*",
       "chrome://chrome-signin/*",
       "chrome://home/*",
       "chrome://media-router/*",
@@ -590,6 +595,14 @@
       "chrome://oobe/*",
       "chrome://assistant-optin/*"
     ]
+  }, {
+    "internal": true,
+    "channel": "stable",
+    "contexts": ["webui"],
+    "matches": [
+      "chrome://brave/*"
+    ]
+
   }],
   "webViewRequest": [{
     "dependencies": ["permission:webview"],
@@ -598,6 +611,7 @@
     "channel": "stable",
     "contexts": ["webui"],
     "matches": [
+      "chrome://brave/*",
       "chrome://chrome-signin/*",
       "chrome://home/*",
       "chrome://media-router/*",
diff --git a/extensions/renderer/module_system.cc b/extensions/renderer/module_system.cc
index a83c07e09f7217bf0a02a13edba1cdc1cf6bd973..9df5031df2f275fd3e898f1a3a6a41ce7fb7cc3e 100644
--- a/extensions/renderer/module_system.cc
+++ b/extensions/renderer/module_system.cc
@@ -416,11 +416,13 @@ void ModuleSystem::LazyFieldGetterInner(
   // time, it means something went wrong. Bail out early rather than going
   // through the initialization process again (since bindings may not expect to
   // run multiple times).
+#ifdef MUON_CHROMIUM_BUILD
+  // broken commit in upstream see https://codereview.chromium.org/2835643004#msg23
   if (!module_system->loaded_modules_.insert(name).second) {
     Warn(isolate, "Previous API instantiation failed.");
     return;
   }
-
+#endif
   // Switch to our v8 context because we need functions created while running
   // the require()d module to belong to our context, not the current one.
   v8::Context::Scope context_scope(context);
diff --git a/extensions/renderer/resources/guest_view/guest_view_container.js b/extensions/renderer/resources/guest_view/guest_view_container.js
index d985c0df7a9cb9543003ac32751f3fc80633248a..02bd6daf7e48de8345ce3be506e02110af30872d 100644
--- a/extensions/renderer/resources/guest_view/guest_view_container.js
+++ b/extensions/renderer/resources/guest_view/guest_view_container.js
@@ -26,6 +26,7 @@ function GuestViewContainer(element, viewType) {
   privates(this).internalElement = this.createInternalElement$();
   this.setupFocusPropagation();
   var shadowRoot = this.element.createShadowRoot();
+  shadowRoot.innerHTML = '<style>:host { display: flex; }</style>'
   shadowRoot.appendChild(privates(this).internalElement);
 
   GuestViewInternalNatives.RegisterView(this.viewInstanceId, this, viewType);
@@ -212,8 +213,9 @@ function registerInternalElement(viewType) {
   proto.createdCallback = function() {
     this.setAttribute('type', 'application/browser-plugin');
     this.setAttribute('id', 'browser-plugin-' + IdGenerator.GetNextId());
-    this.style.width = '100%';
-    this.style.height = '100%';
+    // this.style.width = '100%';
+    // this.style.height = '100%';
+    this.style.flex = '1 1 auto';
   };
 
   proto.attachedCallback = function() {
diff --git a/media/base/media_switches.cc b/media/base/media_switches.cc
index 5fb8f3c203599358e3cc2e99666844852dfd111a..42ca1a9e39230a383b6209297835b2874973373d 100644
--- a/media/base/media_switches.cc
+++ b/media/base/media_switches.cc
@@ -416,7 +416,7 @@ std::string GetEffectiveAutoplayPolicy(const base::CommandLine& command_line) {
     return switches::autoplay::kDocumentUserActivationRequiredPolicy;
 
 // The default value is platform dependent.
-#if defined(OS_ANDROID)
+#if defined(OS_ANDROID) || !defined(MUON_CHROMIUM_BUILD)
   return switches::autoplay::kUserGestureRequiredPolicy;
 #else
   return switches::autoplay::kNoUserGestureRequiredPolicy;
diff --git a/net/BUILD.gn b/net/BUILD.gn
index 7f9901a8826ce131181b3febdef9b911bae23d12..fb1d8dccc32bf4d287440e3ac301bc37eb77ebf9 100644
--- a/net/BUILD.gn
+++ b/net/BUILD.gn
@@ -364,6 +364,10 @@ component("net") {
     "ssl/token_binding.h",
     "third_party/quic/core/quic_error_codes.cc",
     "third_party/quic/core/quic_error_codes.h",
+    # muon override
+    "//electron/chromium_src/net/base/host_port_pair_auth.cc",
+    "//electron/chromium_src/net/base/url_auth_util.cc",
+    "//electron/chromium_src/net/socket/socks5_client_socket_auth.cc",
   ]
   net_unfiltered_sources = []
 
diff --git a/net/base/host_port_pair.cc b/net/base/host_port_pair.cc
index ec8248449dbcd4156e361fcc8781ce0712f26a02..e9f4dce79a73c1949293c45486606377f4f11ebb 100644
--- a/net/base/host_port_pair.cc
+++ b/net/base/host_port_pair.cc
@@ -18,9 +18,11 @@
 namespace net {
 
 HostPortPair::HostPortPair() : port_(0) {}
+#if 0                           // muon override
 HostPortPair::HostPortPair(const std::string& in_host, uint16_t in_port)
     : host_(in_host), port_(in_port) {
 }
+#endif
 
 // static
 HostPortPair HostPortPair::FromURL(const GURL& url) {
@@ -50,12 +52,14 @@ HostPortPair HostPortPair::FromString(const std::string& str) {
   return host_port_pair;
 }
 
+#if 0                           // muon override
 std::string HostPortPair::ToString() const {
   std::string ret(HostForURL());
   ret += ':';
   ret += base::UintToString(port_);
   return ret;
 }
+#endif
 
 std::string HostPortPair::HostForURL() const {
   // TODO(rtenneti): Add support for |host| to have '\0'.
diff --git a/net/base/host_port_pair.h b/net/base/host_port_pair.h
index a5ee6bda3ff542624b484b7a11811b708fec3e11..0d635e6dd1242382bd5845f6cb7674dc32c58b5d 100644
--- a/net/base/host_port_pair.h
+++ b/net/base/host_port_pair.h
@@ -23,6 +23,8 @@ class NET_EXPORT HostPortPair {
   HostPortPair();
   // If |in_host| represents an IPv6 address, it should not bracket the address.
   HostPortPair(const std::string& in_host, uint16_t in_port);
+  HostPortPair(const std::string& username, const std::string& password,
+               const std::string& in_host, uint16_t in_port);
 
   // Creates a HostPortPair for the origin of |url|.
   static HostPortPair FromURL(const GURL& url);
@@ -37,18 +39,23 @@ class NET_EXPORT HostPortPair {
   // TODO(willchan): Define a functor instead.
   // Comparator function so this can be placed in a std::map.
   bool operator<(const HostPortPair& other) const {
-    return std::tie(port_, host_) < std::tie(other.port_, other.host_);
+    return std::tie(port_, host_, username_, password_) <
+      std::tie(other.port_, other.host_, other.username_, other.password_);
   }
 
   // Equality test of contents. (Probably another violation of style guide).
   bool Equals(const HostPortPair& other) const {
-    return host_ == other.host_ && port_ == other.port_;
+    return username_ == other.username_ && password_ == other.password_ &&
+      host_ == other.host_ && port_ == other.port_;
   }
 
   bool IsEmpty() const {
     return host_.empty() && port_ == 0;
   }
 
+  const std::string& username() const { return username_; }
+  const std::string& password() const { return password_; }
+
   const std::string& host() const {
     return host_;
   }
@@ -72,6 +79,8 @@ class NET_EXPORT HostPortPair {
   size_t EstimateMemoryUsage() const;
 
  private:
+  std::string username_;
+  std::string password_;
   // If |host_| represents an IPv6 address, this string will not contain
   // brackets around the address.
   std::string host_;
diff --git a/net/base/proxy_server.cc b/net/base/proxy_server.cc
index da31a40fbe8dc454dd24cb368c3af7d0b8c3506d..624d663b070e0eaf96a420c52a529525d7b7fed3 100644
--- a/net/base/proxy_server.cc
+++ b/net/base/proxy_server.cc
@@ -8,6 +8,7 @@
 
 #include "base/strings/string_util.h"
 #include "base/trace_event/memory_usage_estimator.h"
+#include "net/base/url_auth_util.h"
 #include "net/base/url_util.h"
 #include "net/http/http_util.h"
 
@@ -226,7 +227,7 @@ ProxyServer ProxyServer::FromSchemeHostAndPort(
     std::string host;
     int port = -1;
     // If the scheme has a host/port, parse it.
-    bool ok = ParseHostAndPort(host_and_port, &host, &port);
+    bool ok = ParseAuthHostAndPort(host_and_port, &host, &port);
     if (!ok)
       return ProxyServer();  // Invalid -- failed parsing <host>[":"<port>]
 
diff --git a/net/http/BUILD.gn b/net/http/BUILD.gn
index d00da41da1d8bbc40d8a85d582c1966ed22eaaf1..c308acaeabef9e90161aeef293fc1a2f743dbe07 100644
--- a/net/http/BUILD.gn
+++ b/net/http/BUILD.gn
@@ -10,8 +10,8 @@ compiled_action("generate_transport_security_state") {
 
   # Inputs in order expected by the command line of the tool.
   inputs = [
-    "transport_security_state_static.json",
-    "transport_security_state_static.pins",
+    "//electron/atom/browser/resources/transport_security_state_static.json",
+    "//electron/atom/browser/resources/transport_security_state_static.pins",
     "transport_security_state_static.template",
   ]
   outputs = [
diff --git a/net/http/http_util.cc b/net/http/http_util.cc
index e26c7d78b7d379dd010ba6ac6afdf494ecd5c563..3e827a41f18577b1f1f4f9744cfab83f9b33a4c7 100644
--- a/net/http/http_util.cc
+++ b/net/http/http_util.cc
@@ -41,8 +41,8 @@ void TrimLWSImplementation(ConstIterator* begin, ConstIterator* end) {
 // static
 std::string HttpUtil::SpecForRequest(const GURL& url) {
   // We may get ftp scheme when fetching ftp resources through proxy.
-  DCHECK(url.is_valid() && (url.SchemeIsHTTPOrHTTPS() || url.SchemeIs("ftp") ||
-                            url.SchemeIsWSOrWSS()));
+  // DCHECK(url.is_valid() && (url.SchemeIsHTTPOrHTTPS() || url.SchemeIs("ftp") ||
+  //                           url.SchemeIsWSOrWSS()));
   return SimplifyUrlForRequest(url).spec();
 }
 
diff --git a/net/http/transport_security_state.cc b/net/http/transport_security_state.cc
index 2dc467772e8625ef702c5e28165b1f161f0c7932..a09e271f10d83a2bd24f667cb927c54b1915cdaa 100644
--- a/net/http/transport_security_state.cc
+++ b/net/http/transport_security_state.cc
@@ -414,6 +414,10 @@ TransportSecurityState::TransportSecurityState()
   enable_static_pins_ = false;
   enable_static_expect_ct_ = false;
 #endif
+
+#if !defined(MUON_CHROMIUM_BUILD)
+  enable_static_pins_ = true;
+#endif
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
 }
 
diff --git a/net/log/net_log_event_type_list.h b/net/log/net_log_event_type_list.h
index 3c5cbce3e412cd76459d3289a6031e78b743abdb..df756b0498af45f736fddc5870761a32fcd58e1f 100644
--- a/net/log/net_log_event_type_list.h
+++ b/net/log/net_log_event_type_list.h
@@ -2124,6 +2124,12 @@ EVENT_TYPE(SOCKS5_GREET_WRITE)
 // The time spent waiting for the "greeting" response from the SOCKS server.
 EVENT_TYPE(SOCKS5_GREET_READ)
 
+// The time spent sending authentication to the SOCKS server
+EVENT_TYPE(SOCKS5_AUTH_WRITE)
+
+// The time spent waiting for the authentication response from the SOCKS server
+EVENT_TYPE(SOCKS5_AUTH_READ)
+
 // The time spent sending the CONNECT request to the SOCKS server.
 EVENT_TYPE(SOCKS5_HANDSHAKE_WRITE)
 
diff --git a/net/socket/socks5_client_socket.cc b/net/socket/socks5_client_socket.cc
index 784bcef533288d1eced7daa5b470b8d99550cd98..490766ba173a5f15f618a8fcdd0de8bfa8c5328d 100644
--- a/net/socket/socks5_client_socket.cc
+++ b/net/socket/socks5_client_socket.cc
@@ -241,6 +241,9 @@ int SOCKS5ClientSocket::DoLoop(int last_io_result) {
         net_log_.EndEventWithNetErrorCode(NetLogEventType::SOCKS5_GREET_READ,
                                           rv);
         break;
+      case STATE_AUTH:
+        rv = DoAuth(rv);
+        break;
       case STATE_HANDSHAKE_WRITE:
         DCHECK_EQ(OK, rv);
         net_log_.BeginEvent(NetLogEventType::SOCKS5_HANDSHAKE_WRITE);
@@ -270,8 +273,6 @@ int SOCKS5ClientSocket::DoLoop(int last_io_result) {
   return rv;
 }
 
-const char kSOCKS5GreetWriteData[] = { 0x05, 0x01, 0x00 };  // no authentication
-
 int SOCKS5ClientSocket::DoGreetWrite() {
   // Since we only have 1 byte to send the hostname length in, if the
   // URL has a hostname longer than 255 characters we can't send it.
@@ -281,8 +282,12 @@ int SOCKS5ClientSocket::DoGreetWrite() {
   }
 
   if (buffer_.empty()) {
-    buffer_ = std::string(kSOCKS5GreetWriteData,
-                          arraysize(kSOCKS5GreetWriteData));
+    const char greeting[] = {
+      0x05,			// SOCKS version
+      0x01,			// number of authentication methods
+      auth_method(),
+    };
+    buffer_ = std::string(greeting, sizeof(greeting));
     bytes_sent_ = 0;
   }
 
@@ -341,14 +346,32 @@ int SOCKS5ClientSocket::DoGreetReadComplete(int result) {
                       NetLog::IntCallback("version", buffer_[0]));
     return ERR_SOCKS_CONNECTION_FAILED;
   }
-  if (buffer_[1] != 0x00) {
+  if (buffer_[1] != auth_method()) {
     net_log_.AddEvent(NetLogEventType::SOCKS_UNEXPECTED_AUTH,
                       NetLog::IntCallback("method", buffer_[1]));
     return ERR_SOCKS_CONNECTION_FAILED;
   }
 
   buffer_.clear();
-  next_state_ = STATE_HANDSHAKE_WRITE;
+  next_state_ = STATE_AUTH;
+  return OK;
+}
+
+int SOCKS5ClientSocket::DoAuth(int rv) {
+  rv = Authenticate(rv, *transport_, net_log_, io_callback_);
+  next_state_ = (rv == OK ? STATE_HANDSHAKE_WRITE : STATE_AUTH);
+  return rv;
+}
+
+uint8_t SOCKS5ClientSocket::auth_method() {
+  return 0x00;
+}
+
+int SOCKS5ClientSocket::Authenticate(int rv,
+                                     ClientSocketHandle& socket,
+                                     NetLogWithSource& net_log,
+                                     CompletionCallback& callback) {
+  DCHECK_EQ(OK, rv);
   return OK;
 }
 
diff --git a/net/socket/socks5_client_socket.h b/net/socket/socks5_client_socket.h
index b6e59ae6b07823087e44ffc40fb7d2d54c6a7c3e..98ee500609b2a72970387324a09da102b7230c14 100644
--- a/net/socket/socks5_client_socket.h
+++ b/net/socket/socks5_client_socket.h
@@ -20,6 +20,7 @@
 #include "net/base/net_export.h"
 #include "net/dns/host_resolver.h"
 #include "net/log/net_log_with_source.h"
+#include "net/socket/socks_client_socket_pool.h"
 #include "net/socket/stream_socket.h"
 #include "net/traffic_annotation/network_traffic_annotation.h"
 #include "url/gurl.h"
@@ -79,11 +80,14 @@ class NET_EXPORT_PRIVATE SOCKS5ClientSocket : public StreamSocket {
   int GetLocalAddress(IPEndPoint* address) const override;
 
  private:
+  friend class SOCKS5ClientSocketAuth;
   enum State {
     STATE_GREET_WRITE,
     STATE_GREET_WRITE_COMPLETE,
     STATE_GREET_READ,
     STATE_GREET_READ_COMPLETE,
+    STATE_AUTH,
+    STATE_AUTH_COMPLETE,
     STATE_HANDSHAKE_WRITE,
     STATE_HANDSHAKE_WRITE_COMPLETE,
     STATE_HANDSHAKE_READ,
@@ -118,6 +122,14 @@ class NET_EXPORT_PRIVATE SOCKS5ClientSocket : public StreamSocket {
   int DoGreetReadComplete(int result);
   int DoGreetWrite();
   int DoGreetWriteComplete(int result);
+  int DoAuth(int result);
+
+  // Authentication hooks.
+  virtual uint8_t auth_method();
+  virtual int Authenticate(int result,
+                           ClientSocketHandle& socket,
+                           NetLogWithSource& net_log,
+                           CompletionCallback& callback);
 
   // Writes the SOCKS handshake buffer into |handshake|
   // and return OK on success.
diff --git a/net/socket/socks_client_socket_pool.cc b/net/socket/socks_client_socket_pool.cc
index d5da29925a083ac263d4c58d893f69552098850b..b2fda922fe442a448c3d3bc562bb12054eae5f19 100644
--- a/net/socket/socks_client_socket_pool.cc
+++ b/net/socket/socks_client_socket_pool.cc
@@ -16,7 +16,7 @@
 #include "net/socket/client_socket_factory.h"
 #include "net/socket/client_socket_handle.h"
 #include "net/socket/client_socket_pool_base.h"
-#include "net/socket/socks5_client_socket.h"
+#include "net/socket/socks5_client_socket_auth.h"
 #include "net/socket/socks_client_socket.h"
 #include "net/socket/transport_client_socket_pool.h"
 
@@ -149,9 +149,11 @@ int SOCKSConnectJob::DoSOCKSConnect() {
 
   // Add a SOCKS connection on top of the tcp socket.
   if (socks_params_->is_socks_v5()) {
-    socket_.reset(new SOCKS5ClientSocket(std::move(transport_socket_handle_),
-                                         socks_params_->destination(),
-                                         socks_params_->traffic_annotation()));
+    socket_.reset(new SOCKS5ClientSocketAuth(
+            std::move(transport_socket_handle_),
+            socks_params_->destination(),
+            socks_params_->traffic_annotation(),
+            socks_params_->transport_params()->destination().host_port_pair()));
   } else {
     socket_.reset(new SOCKSClientSocket(
         std::move(transport_socket_handle_), socks_params_->destination(),
diff --git a/net/url_request/url_request_job.h b/net/url_request/url_request_job.h
index 7a223958751012b2042a91edf85578b00702d565..08a3940915c61746c7bf80d24400875099f9686c 100644
--- a/net/url_request/url_request_job.h
+++ b/net/url_request/url_request_job.h
@@ -292,6 +292,7 @@ class NET_EXPORT URLRequestJob : public base::PowerObserver {
   void OnCallToDelegate(NetLogEventType type);
   void OnCallToDelegateComplete();
 
+ public:
   // Called to read raw (pre-filtered) data from this Job. Reads at most
   // |buf_size| bytes into |buf|.
   // Possible return values:
diff --git a/services/service_manager/sandbox/win/sandbox_win.cc b/services/service_manager/sandbox/win/sandbox_win.cc
index 7beb41460e7d1a7340cca8ebc98a114ec41b3e44..3b3e1aa30f342971b96b4213ed85718d36fb3aa6 100644
--- a/services/service_manager/sandbox/win/sandbox_win.cc
+++ b/services/service_manager/sandbox/win/sandbox_win.cc
@@ -831,6 +831,9 @@ sandbox::ResultCode SandboxWin::StartSandboxedProcess(
           service_manager::switches::kNoSandbox)) {
     base::LaunchOptions options;
     options.handles_to_inherit = handles_to_inherit;
+#if !defined(MUON_CHROMIUM_BUILD)
+    options.start_hidden = true;
+#endif
     if (sandbox_type == SANDBOX_TYPE_NETWORK) {
       // Launch the process in a job to ensure that the network process doesn't
       // outlive the browser. This could happen if there is a lot of I/O on
diff --git a/third_party/blink/renderer/core/editing/editing_behavior.h b/third_party/blink/renderer/core/editing/editing_behavior.h
index 90f13baf5daa216c0832b39137ba87f60aa2ccd2..643caf4e6825e3da6678af6a1a981c42d2bb782b 100644
--- a/third_party/blink/renderer/core/editing/editing_behavior.h
+++ b/third_party/blink/renderer/core/editing/editing_behavior.h
@@ -42,7 +42,7 @@ class CORE_EXPORT EditingBehavior {
   // area, maintain the horizontal position on Windows and Android but extend it
   // to the boundary of the editable content on Mac and Linux.
   bool ShouldMoveCaretToHorizontalBoundaryWhenPastTopOrBottom() const {
-    return type_ != kEditingWindowsBehavior && type_ != kEditingAndroidBehavior;
+    return false;
   }
 
   bool ShouldSelectReplacement() const {
diff --git a/third_party/blink/renderer/core/exported/web_view_impl.cc b/third_party/blink/renderer/core/exported/web_view_impl.cc
index 2acc5921abeb17a8603620b631b9f87eb9907122..ecac38e2ae00250d17d04e27572b1f013ac733c3 100644
--- a/third_party/blink/renderer/core/exported/web_view_impl.cc
+++ b/third_party/blink/renderer/core/exported/web_view_impl.cc
@@ -3000,6 +3000,7 @@ void WebViewImpl::DidCloseContextMenu() {
   LocalFrame* frame = page_->GetFocusController().FocusedFrame();
   if (frame)
     frame->Selection().SetCaretBlinkingSuspended(false);
+  page_->GetContextMenuController().ClearContextMenu();
 }
 
 void WebViewImpl::HidePopups() {
diff --git a/third_party/blink/renderer/core/html/media/autoplay_policy.cc b/third_party/blink/renderer/core/html/media/autoplay_policy.cc
index 70d1323967869929988baea80ead2fb997244ee6..80f262e1bd2711243c6f2d5e6a9a5e66346f0df2 100644
--- a/third_party/blink/renderer/core/html/media/autoplay_policy.cc
+++ b/third_party/blink/renderer/core/html/media/autoplay_policy.cc
@@ -343,6 +343,12 @@ bool AutoplayPolicy::IsGestureNeededForPlaybackIfPendingUserGestureIsLocked()
   if (element_->GetLoadType() == WebMediaPlayer::kLoadTypeMediaStream)
     return false;
 
+  // MUON(darkdh): default allow local files
+  if (element_->GetDocument().origin() == String("null"))
+    return false;
+
+  // MUON(darkdh): prompt autoply permission even for muted video
+#if defined(MUON_CHROMIUM_BUILD)
   // We want to allow muted video to autoplay if:
   // - the flag is enabled;
   // - Data Saver is not enabled;
@@ -362,6 +368,12 @@ bool AutoplayPolicy::IsGestureNeededForPlaybackIfPendingUserGestureIsLocked()
       IsAutoplayAllowedPerSettings()) {
     return false;
   }
+#endif
+
+  // MUON(darkdh): prompt for autoplay permission
+  if ((element_->IsHTMLVideoElement() || element_->IsAudioElement()) &&
+      IsAutoplayAllowedPerSettings())
+    return false;
 
   return true;
 }
diff --git a/third_party/blink/renderer/core/loader/frame_fetch_context.cc b/third_party/blink/renderer/core/loader/frame_fetch_context.cc
index ccfe57146112d3e781ac050db551e6aba26bf3a1..fd7b81b2cf4d91732341fa2bf55ee658b5d0b453 100644
--- a/third_party/blink/renderer/core/loader/frame_fetch_context.cc
+++ b/third_party/blink/renderer/core/loader/frame_fetch_context.cc
@@ -913,7 +913,9 @@ void FrameFetchContext::ModifyRequestForCSP(ResourceRequest& resource_request) {
 void FrameFetchContext::AddClientHintsIfNecessary(
     const ClientHintsPreferences& hints_preferences,
     const FetchParameters::ResourceWidth& resource_width,
-    ResourceRequest& request) {
+    ResourceRequest& request,
+    Resource::Type type) {
+
   WebEnabledClientHints enabled_hints;
 
   // If the feature is enabled, then client hints are allowed only on secure
@@ -923,6 +925,7 @@ void FrameFetchContext::AddClientHintsIfNecessary(
 
   // Check if |url| is allowed to run JavaScript. If not, client hints are not
   // attached to the requests that initiate on the render side.
+  if (type == Resource::kScript)
   if (!AllowScriptFromSourceWithoutNotifying(request.Url()))
     return;
 
@@ -1014,7 +1017,7 @@ void FrameFetchContext::PopulateResourceRequest(
     const FetchParameters::ResourceWidth& resource_width,
     ResourceRequest& request) {
   ModifyRequestForCSP(request);
-  AddClientHintsIfNecessary(hints_preferences, resource_width, request);
+  AddClientHintsIfNecessary(hints_preferences, resource_width, request, type);
 
   const ContentSecurityPolicy* csp = GetContentSecurityPolicy();
   if (csp && csp->ShouldSendCSPHeader(type))
diff --git a/third_party/blink/renderer/core/loader/frame_fetch_context.h b/third_party/blink/renderer/core/loader/frame_fetch_context.h
index d2a808077e76151e66c9fc9dcb858a2e296c2808..de8ba1653e235af7628553f49114f4f08f25f8b9 100644
--- a/third_party/blink/renderer/core/loader/frame_fetch_context.h
+++ b/third_party/blink/renderer/core/loader/frame_fetch_context.h
@@ -160,7 +160,8 @@ class CORE_EXPORT FrameFetchContext final : public BaseFetchContext {
   void ModifyRequestForCSP(ResourceRequest&);
   void AddClientHintsIfNecessary(const ClientHintsPreferences&,
                                  const FetchParameters::ResourceWidth&,
-                                 ResourceRequest&);
+                                 ResourceRequest&,
+                                 Resource::Type);
 
   MHTMLArchive* Archive() const override;
 
diff --git a/third_party/blink/renderer/platform/bindings/v8_per_isolate_data.cc b/third_party/blink/renderer/platform/bindings/v8_per_isolate_data.cc
index 44cb5a9489f1938b0078f20fedc0ef7831a3d9e1..51212af2879e940931ea49cc10eac9707541bbe3 100644
--- a/third_party/blink/renderer/platform/bindings/v8_per_isolate_data.cc
+++ b/third_party/blink/renderer/platform/bindings/v8_per_isolate_data.cc
@@ -55,7 +55,8 @@ v8::Isolate* MainThreadIsolate() {
 static V8PerIsolateData* g_main_thread_per_isolate_data = nullptr;
 
 static void BeforeCallEnteredCallback(v8::Isolate* isolate) {
-  CHECK(!ScriptForbiddenScope::IsScriptForbidden());
+  // TODO(jochen): Re-enable this once https://crbug.com/728583
+  // CHECK(!ScriptForbiddenScope::IsScriptForbidden());
 }
 
 static void MicrotasksCompletedCallback(v8::Isolate* isolate) {
diff --git a/third_party/boringssl/BUILD.generated.gni b/third_party/boringssl/BUILD.generated.gni
index 67ff124e5009500f9f853aff9b5beb392c6a52b5..e4743ab9eeea0b6ea177ac176f8cc17c4923869e 100644
--- a/third_party/boringssl/BUILD.generated.gni
+++ b/third_party/boringssl/BUILD.generated.gni
@@ -386,6 +386,24 @@ ssl_headers = [
   "src/include/openssl/tls1.h",
 ]
 
+decrepit_sources = [
+  "src/decrepit/bio/base64_bio.c",
+  "src/decrepit/blowfish/blowfish.c",
+  "src/decrepit/cast/cast.c",
+  "src/decrepit/cast/cast_tables.c",
+  "src/decrepit/des/cfb64ede.c",
+  "src/decrepit/dh/dh_decrepit.c",
+  "src/decrepit/dsa/dsa_decrepit.c",
+  "src/decrepit/evp/dss1.c",
+  "src/decrepit/evp/evp_do_all.c",
+  "src/decrepit/rc4/rc4_decrepit.c",
+  "src/decrepit/ripemd/ripemd.c",
+  "src/decrepit/rsa/rsa_decrepit.c",
+  "src/decrepit/ssl/ssl_decrepit.c",
+  "src/decrepit/x509/x509_decrepit.c",
+  "src/decrepit/xts/xts.c",
+]
+
 crypto_sources_ios_aarch64 = [
   "ios-aarch64/crypto/chacha/chacha-armv8.S",
   "ios-aarch64/crypto/fipsmodule/aesv8-armx64.S",
diff --git a/third_party/boringssl/BUILD.gn b/third_party/boringssl/BUILD.gn
index d31a9f29fa9c12e753708b2a1e75c33b70924300..4977f3268d04c2d3fd23c93e361a7f29be5113ed 100644
--- a/third_party/boringssl/BUILD.gn
+++ b/third_party/boringssl/BUILD.gn
@@ -44,7 +44,7 @@ config("no_asm_config") {
   defines = [ "OPENSSL_NO_ASM" ]
 }
 
-all_sources = crypto_sources + ssl_sources
+all_sources = crypto_sources + ssl_sources + decrepit_sources
 all_headers = crypto_headers + ssl_headers
 
 # Windows' assembly is built with Yasm. The other platforms use the platform
diff --git a/third_party/crashpad/crashpad/handler/crash_report_upload_thread.cc b/third_party/crashpad/crashpad/handler/crash_report_upload_thread.cc
index 4783ecb252b11a56550d4a6f684bd15c89fc4eb7..9ffdb7c00af09accc1883c525332271faebd5241 100644
--- a/third_party/crashpad/crashpad/handler/crash_report_upload_thread.cc
+++ b/third_party/crashpad/crashpad/handler/crash_report_upload_thread.cc
@@ -170,7 +170,11 @@ void CrashReportUploadThread::ProcessPendingReport(
         // If the most recent upload attempt occurred within the past hour,
         // dont attempt to upload the new report. If it happened longer ago,
         // attempt to upload the report.
+#if defined(MUON_CHROMIUM_BUILD)
         constexpr int kUploadAttemptIntervalSeconds = 60 * 60;  // 1 hour
+#else
+        constexpr int kUploadAttemptIntervalSeconds = 1 * 60;  // 1 min
+#endif
         if (now - last_upload_attempt_time < kUploadAttemptIntervalSeconds) {
           database_->SkipReportUpload(
               report.uuid, Metrics::CrashSkippedReason::kUploadThrottled);
diff --git a/ui/views/controls/menu/menu_controller.cc b/ui/views/controls/menu/menu_controller.cc
index beecb7f271772cc9a19d2ca5476d60069e218e17..fc4b16eb6999700ad212319a3b525679a4b770df 100644
--- a/ui/views/controls/menu/menu_controller.cc
+++ b/ui/views/controls/menu/menu_controller.cc
@@ -621,6 +621,7 @@ bool MenuController::OnMouseDragged(SubmenuView* source,
     return true;
   }
   MenuItemView* mouse_menu = NULL;
+  base::WeakPtr<MenuController> this_ref = AsWeakPtr();
   if (part.type == MenuPart::MENU_ITEM) {
     // If there is no menu target, but a submenu target, then we are interacting
     // with an empty menu item within a submenu. These cannot become selection
@@ -645,7 +646,10 @@ bool MenuController::OnMouseDragged(SubmenuView* source,
       }
     }
   }
-  UpdateActiveMouseView(source, event, mouse_menu);
+  // The above code may have deleted us, so MenuController may have
+  // been destroyed.
+  if (this_ref)
+    UpdateActiveMouseView(source, event, mouse_menu);
 
   return true;
 }
